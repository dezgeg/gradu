\section{Johdanto}

Tiedostojärjestelmät ovat se pääasiallinen tapa jolla sekä käyttäjät että sovellukset voivat käsitellä tietokoneen massamuistia,
eli ylipäätänsä tallentaa tietoa siten että se säilyy tietokoneen virran katkaisemisen jälkeenkin.
Melkeinpä jokaiselle tietokoneen käyttäjälle tuleekin siis tutuksi käyttöjärjestelmän tarjoamat mahdollisuudet tiedostojen käsittelyyn,
kuten tiedostojen tallentamiseen kiintolevylle, niiden poistamiseen tai kopioimiseen esimerkiksi USB-tikulle.
Sekä käyttäjän että sovelluskehittäjän näkökulmasta tiedostojärjestelmän sisäinen toiminta on abstraktoitu verrattaen hyvin.
Riippumatta siitä onko käyttäjä avaamassa dokumenttia tekstinkäsittelyohjelmalla useiden teratavujen kokoiselta mekaaniselta kiintolevyltä taikka muutaman gigatavun flash-muistitikulta,
on käyttäjäkokemus samanlainen ja tekstinkäsittelyohjelma käyttää täsmälleen samoja käyttöjärjestelmän rajapintoja tiedostojen käsittelyyn.
Moderneissa käyttöjärjestelmissä on sovellusten käyttämät rajapinnat tiedostojen käsittelyyn eroteltu itse tiedostojärjestelmästä~\cite{UnixFsBook}.
% UnixFsBook: page 6, FSS, SVR3, 1987.
Tämä mahdollistaa sen, että käyttöjärjestelmä voi tukea useita tiedostojärjestelmiä samaan aikaan,
jolloin samaan tietokoneeseen voi olla samaan aikaan liitettynä monentyyppisiä tiedostojärjestelmiä joko eri tallennusmedioilla tai saman levyn eri osioilla.
Uusia tiedostojärjestelmiä kehitetäänkin jatkuvasti muun muassa parantamaan suorituskykyä tai tuomaan uusia ominaisuuksia.
Esimerkiksi Microsoft on vuosien saatossa vaihtanut Windows-käyttöjärjestelmän oletustiedostojärjestelmän FAT:sta NTFS:ään~\cite{BefsBook},
% BefsBook: page 40
ja kuten tämän tutkielman myöhemmissä luvuissa nähdään,
on Linux-maailmassa ollut reilustikin valinnanvaraa erityyppisissä tiedostojärjestelmissä.

Eräs motivaattori uusien tiedostojärjestelmien kehittämiseen on luotettavuuden parantaminen.
Useat aikanaan käytetyt tiedostojärjestelmät,
kuten DOS-käyttöjärjestelmän FAT tai alkuperäisen Unixin tiedostojärjestelmä,
olivat nykymittapuulla erittäin yksinkertaisia eivätkä antaneet juuri mitään takuuta sille että tiedostojärjestelmän eheys säilyisi \emph{kaatumistilanteissa}.
Tyypillisiä tiedostojärjestelmän kaatumistilanteita ovat esimerkiksi koko tietokoneen sammuminen virtakatkoksen takia tai
tilanteita jossa järjestelmä pitää käynnistää uudelleen sammuttamatta sitä turvallisesti,
esimerkiksi jonkin vakavan käyttöjärjestelmävirheen takia.
Kyseisillä tiedostojärjestelmillä kaatumistilannetta seurasikin aina koko tiedostojärjestelmän tarkistus \texttt{fsck}-ohjelmalla,
joka kävi koko levyn läpi ja yritti parhaansa mukaan palauttaa tiedostojärjestelmän toimivaan tilaan~\cite{Ext2Journal}.
Fsck-ohjelman suorituksen aikana tiedostojärjestelmä ei ole normaalisti käytettävissä,
mikä tiedostojärjestelmän käyttötarkoituksesta riippuen tarkoittikin mahdollista käyttökatkosta koko järjestelmälle.
Modernimmat tiedostojärjestelmät, kuten Linuxin \texttt{ext3} vuodelta 2001, ovatkin suunniteltu selviämään kaatumistilanteista nopeasti ja turvallisesti,
joten tämänkaltaiset pitkät käyttökatkot tiedostojärjestelmätarkistusten takia ovat olleet historiaa jo tovin.

Kokonaisuutena kaatumistilanteista selviytyminen on monitahoinen ongelma.
Vaikka siis käytettävä tiedostojärjestelmä vaikuttaakin merkittävästi siihen mitä seurauksia järjestelmän kaatumistilanteesta johtaa,
on sovellusohjelmallakin oma vastuunsa siitä että käyttäjän dataa ei korruptoidu.
Tiedostojärjestelmäkutsujen käyttö kaatumisturvallisesti ei välttämättä ole täysin suoraviivaista,
vaan sovellusohjelmoijan täytyy usein tehdä erityistoimenpiteitä jotta kokonaisuudesta tulee kaatumisturvallinen.
Toisaalta itse tiedostojärjestelmätoteutuksen täytyy huolehtia siitä että tiedostojärjestelmän sisäisten tietorakenteiden eheys säilyy kaatumistilanteessa ja että toteutus pystyy täyttämään tiedostojärjestelmärajapinnan asettamat vaatimukset joihin sovellukset luottavat.

Tämän tutkielman tavoitteena on tarkastella kaatumisturvallisuutta molemmista näkökulmista.
Ensimmäisessä osuudessa keskitytään tarkastelemaan sovellusten näkökulmasta:
luvussa~\ref{ChapUnixFsBasics} tarkastellaan Unix-tiedosto\-järjestelmärajapintojen perusteita ja luvussa~\ref{ChapPosixDataConsistency} kuinka niitä tulisi käyttää kaatumisturvallisuuden takaamiseksi.
Luvussa~\ref{ChapPosixSafetyStudy} tarkastellaan käytännön tutkimusta siitä,
miten kaatumistilanteet vaikuttavat eri tiedostojärjestelmillä ja kuinka hyvin olemassa olevat sovellukset ottavat ne huomioon.
Tutkielman toisessa osuudessa keskitytään tarkastelemaan tiedostojärjestelmien sisäisten tietorakenteiden eheyden säilymistä.
Luvussa~\ref{ChapExt2Fs} esitellään perinteisen mutta ei kovin kaatumisturvallisen Linux-tiedostojärjestelmän, \texttt{ext2}:n, sisäistä rakennetta ja luvussa~\ref{ChapExt2Crash} mitä seurauksia kaatumistilanteilla on \texttt{ext2}:lle.
Lopuksi esitellään tekniikoita,
joita modernit tiedostojärjestelmät käyttävät tiedostojärjestelmän eheyden säilyttämiseen kaatumistilanteissa: kirjaavia tiedostojärjestelmiä luvussa~\ref{ChapJournallingFs}, lokipohjaisia tiedostojärjestelmiä luvussa~\ref{ChapLogStructured}, kirjoittaessa kopioivia tiedostojärjestelmiä luvussa~\ref{ChapCopyOnWrite} ja kirjoitusjärjestyksen hallintaan perustuvia tiedostojärjestelmiä luvussa~\ref{ChapSoftUpdates}.
% FIXME: motivaatio etc.

\section{Unix-tiedostojärjestelmien perusteet}
\label{ChapUnixFsBasics}

Vaikka tiedostojärjestelmät konseptina ovatkin todennäköisesti tuttuja monille tietokoneenkäyttäjille,
on laitettava merkille ettei tiedostojärjestelmälle ole olemassa mitään yhtä oikeaa määritelmää
vaan eri käyttöjärjestelmissä ne toimivat hieman eri tavoilla.
Koska tässä tutkielmassa tarkastellaan pääosin Unix-tyyppisten käyttöjärjestelmien tiedostojärjestelmiä,
tutustutaan ensin niiden periaatteisiin läheisemmin.
Nykypäivän Unix-tyyppisten käyttöjärjestelmien tiedostojärjestelmärajapintoja yhdistää pääosin \emph{POSIX (Portable Operating System Interface for uniX)}-standardi~\cite{PosixSpec}.
% FIXME: jatka tätä ihan vähäsen

\subsection{Unixin ja POSIX-standardin lyhyt historia}

Unix-käyttöjärjestelmän kehitys alkoi vuonna 1969 AT\&T:n Bell Labs-kehityslaboratoriossa.
Ken Thompson ja Dennis Ritchie olivat olleet kehittämässä MULTICS-nimistä interaktiivista usean käyttäjän moniajokäyttöjärjestelmää yhdessä General Electricin ja MIT:n yliopiston kanssa.
MULTICS-projektin tavoitteet olivat aikaansa nähden kunnianhimoisia ja käyttöjärjestelmän valmistuminen näyttikin venyvän ja venyvän, joten Bell Labs vetäytyi lopulta pois projektista.
Thompson ja Ritchie eivät olleet tyytyväisiä tilanteeseen vaan alkoivat kehittää omaa MULTICSin inspiroimaa käyttöjärjestelmää PDP-7-tietokoneelle~\cite{UnixHistoryBook}.
Jo samana vuonna Unix oli jo täysin omavarainen, eli Unixin kehitystä pystyttiin jatkamaan Unixilla itsellään.
Aluksi Unixia kehitettiin pääasiassa tutkimuskäyttöön mutta myös AT\&T:n sisäiseen toimistokäyttöön,
kuten tekstidokumenttien käsittelyyn sekä latomiseen~\cite{UnixFsBook}.
Kuitenkin vuonna 1974 Unix tuotiin akateemisen maailman tietoisuuteen Thompsonin ja Ritchien julkaisemalla artikkelilla ``The UNIX time-sharing system''~\cite{UnixPaper} jonka seurauksena ulkopuolisetkin kiinnostuivat Unixista.

Bell Labsin emoyhtiöllä oli kuitenkin tuohon aikoihin monopoliasema Yhdysvaltojen puhelinverkkotoimintoihin,
joten kilpailuviraston kanssa tehdyn sopimuksen pohjalta sen oli kiellettyä alkaa tekemään liiketoimintaa muilla toimialueilla eikä voinut siten tuotteistaa Unixia.
Sen sijaan Unixin lähdekoodia alettiin lisensoida nimellistä kertakorvausta vastaan pääasiassa yliopistoille mutta myös joillekin yrityksille,
jotka alkoivat tehdä omia muutoksiaan Unixiin ja jaella tai markkinoida niitä~\cite{UnixFsBook}.
Ensimmäinen akateemisen maailman tuottama Unix-johdannainen on Berkeleyn yliopiston BSD (Berkeley Software Distribution) josta ensimmäinen versio 1BSD julkaistiin vuonna 1977.
80-luvun aikana tunnettuja markkinoille tuli muun muassa Microsoftin Xenix, Sun Microsystemsin SunOS sekä IBM:n AIX.
AT\&T:n puhelinverkkotoiminnan monopoliaseman purkaantuminen avasi sille tilaisuuden myydä Unixia kaupallisesti,
joka julkaistiin Unix System V-nimellä vuonna 1983.

Markkinoilla oli siis saatavilla useita periaatteessa Unix-pohjaisia käyttöjärjestelmiä mutta jotka kaikki käytännössä toimivat hieman eri tavalla.
Sovellusohjelmoijan kannalta tämä hankaloitti huomattavasti monella eri Unix-järjestelmällä toimivien ohjelmien toteutusta.
Tämän ratkaisemiseksi kehiteltiin POSIX-standardi~\cite{PosixSpec} yhtenäistämään eri Unix-toteutusten tarjoamat sovellusrajapinnat.
Ensimmäinen versio standardista julkaistiin vuonna 1988.
POSIX-standardi määrittelee muun muassa komentorivityökaluja sekä C-kielisiä rajapintoja muun muassa tiedostojen, säikeiden ja prosessien hallintaan.
Käytännössä mitään Linux-jakelua ei virallisesti ole sertifioitu POSIX-yhteensopivaksi~\cite{PosixLinuxCompat}
mutta käytännössä kehittäjät tähtäävät POSIX-yhteensopivuuteen~\cite{LinuxKernelBook}.

Tiedostojärjestelmien käsittelyä varten POSIX tarjoaa sekä komentorivikomentoja kuten \texttt{ls}, \texttt{cp}, \texttt{rm} pääasiassa käyttäjien käyttöön että ohjelmointirajapintoja C-ohjelmointikielellä sovellusten toteuttamista varten.
Valtaosa näistä ohjelmointirajapinnoista toimivat varsin matalalla tasolla,
joista sovellusohjelmoijan täytyy itse koostaa useat vähänkään monimutkaisemmat tiedostojärjestelmäoperaatiot.
Erityisesti tiedostojärjestelmän käyttö kaatumisturvallisesti vaatii ohjelmoijalta erityistä kykyä ja ymmärrystä käyttää POSIX-rajapintoja oikein,
mitä käsitellään myöhemmin luvussa~\ref{ChapPosixDataConsistency}.
Tästä syystä esitelläänkin seuraavaksi lyhyesti tärkeimmät POSIXin tarjoamat C-rajapinnat tiedostojen käsittelyyn.

\subsection{POSIX-tiedostojärjestelmärajapintojen perusteet}
POSIX-tiedostojärjestelmä on \emph{hierarkkinen tiedostojärjestelmä},
eli tavallisten tiedostojen lisäksi tiedostojärjestelmä tukee \emph{hakemistoja},
jotka voivat sisältää mielivaltaisen määrän tiedostoja tai hakemistoja.
Tiedostojärjestelmä muodostaa siis puurakenteen, mistä tulee tämä hierarkkisen määritelmä.
Kaikilla tiedostoilla ja hakemistoilla on jokin käyttäjän antama nimi,
jonka täytyy olla uniikki siinä hakemistossa jossa kyseinen tiedosto tai hakemisto sijaitsee.
Mikä tahansa tiedosto tai hakemisto Unix-tiedostojärjestelmässä voidaan siis paikantaa \emph{tiedostopolulla},
eli merkkijonolla jossa \texttt{/}-merkillä on eroteltuna alihakemistojen nimet joita pitkin pitää kulkea tiedoston paikantaakseen.
Esimerkiksi tiedostopolku \texttt{/home/tuomas/gradu.tex}
tarkoittaa että juurihakemistosta \texttt{/} paikannetaan alihakemisto \texttt{home}, josta löytyy alihakemisto \texttt{tuomas}, jonka sisällä on viimein tiedosto \texttt{gradu.tex}.

% \texttt{/}-merkillä alkavat tiedostopolut ovat \emph{absoluuttisia} polkuja,
% muut polut ovat \emph{suhteellisia} polkuja.
% Jokaisella ajonaikaisella prosessilla on oma nykyinen hakemistonsa (current directory),
% jonka suhteen suhteelliset polut tulkitaan.
% Esimerkiksi prosessilla jonka nykyinen hakemisto on \texttt{/home/tuomas},
% viittaisi polku \texttt{Downloads/kuva.jpg} tiedostoon \texttt{/home/tuomas/Downloads/kuva.jpg}.

POSIXissa on kaksi erityistä tiedostonimeä, \texttt{.} ja \texttt{..}, joiden voidaan mieltää löytyvän jokaisesta hakemistosta.
Näistä \texttt{.} viittaa aina siihen hakemistoon jossa se sijaitsee ja \texttt{..} viittaa ylempään hakemistoon hakemistopuussa.
Siis esimerkiksi polku \texttt{/home/tuomas/.} viittaa samaan hakemistoon kuin polku \texttt{/home/tuomas}.
Lisäksi \texttt{.}-nimeä voi käyttää missä tahansa kohtaa polkua,
eli esimerkiksi \texttt{/home/./tuomas} tai \texttt{/home/././tuomas/././.} viittaavat edelleen samaan hakemistoon.
Nimi \texttt{..} taas viittaa ylempään tasoon hakemistorakenteessa,
eli tiedostopolku \texttt{/home/tuomas/..} viittaa samaan hakemistoon kuin tiedostopolku \texttt{/home}.
Juurihakemiston tapauksessa \texttt{..}-nimi vie takaisin juurihakemistoon itseensä, eli tiedostopolut \texttt{/..} ja \texttt{/} toimivat identtisesti.

Nimen lisäksi kaikilla tiedostoilla ja hakemistoilla on jonkin verran metadataa muun muassa käyttöoikeuksille sekä aikaleimoille.
Koska useissa yhteyksissä sekä tiedostot että hakemistot toimivat yhtenäisesti,
on Unix-tiedostojärjestelmistä puhuttaessa yleisesti konventio sanoa että Unixissa hakemistotkin ovat tiedostoja,
jolloin käytetään termiä \emph{tavallinen tiedosto} (\emph{regular file}) viittaamaan yleiskielen termiin ``tiedosto''.

Jokaiselle tiedostolle on tallennettu sen omistavan käyttäjän tunnus (\emph{user id, UID}) sekä ryhmän tunnus (\emph{group id, GID}).
Näiden lisäksi tiedostoilla on kolme käyttöoikeutta: luku-, kirjoitus- sekä suoritusoikeus,
jotka tiedoston omistaja voi määritellä erikseen joko tiedoston omistajalle, samaan ryhmään kuuluville käyttäjille sekä ulkopuolisille käyttäjille.
Unix-tiedostojärjestelmä myös ylläpitää kolmea aikaleimaa eri tarkoituksiin:
milloin tiedoston sisältöä on viimeksi luettu (access timestamp), milloin tiedoston sisältöä on viimeksi muokattu (data modification timestamp) sekä milloin tiedostoa ylipäätään on muokattu (status change timestamp).

Eräs varsin erikoinen ominaisuus on \emph{kovat linkit} (\emph{hard link}), mikä käytännössä tarkoittaa että tiedostolla (mutta ei hakemistolla) voi olla useita nimiä tiedostojärjestelmässä.
Kovan linkin luominen tehdään olemassa olevalle tiedostolle,
jonka jälkeen kyseistä tiedostoa voi käsitellä täysin identtisesti sekä alkuperäisellä nimellä että linkin nimellä.
Jälkikäteen ei ole edes mahdollista erottaa kumpi tiedoston nimistä oli se jolla tiedosto oli alunperin luotu.
Yhden samaan tiedostoon viittaavan nimen poistaminen ei vaikuta muihin nimiin mitenkään.
Sanotaankin, että Unix-tiedostojärjestelmässä tiedostojen ja hakemistojen nimi on erillään niiden \emph{inodesta}, joka sisältää kaiken informaation kuten sisällön ja attribuutit.
Hakemistot sen sijaan sisältävät vain viitteen nimestä inodeen.
Jokaisella inodella on yksilöivä numero jolla inodeen viitataan.
Sovellusohjelmoijan tai käyttäjän kannalta inoden numerolla ei tosin ole muuta käyttöä kuin että sillä voidaan selvittää viittaavatko kaksi eri tiedostonimeä samaan inodeen.

Unixissa tavallisia tiedostoja voi käsitellä vain tavupohjaisina,
eli mikäli sovellus tarvitsee esimerkiksi tietuepohjaista tiedostonkäsittelyä jää sen toteutus sovelluksen vastuulle.

Tavallisten tiedostojen ja hakemistojen lisäksi Unix-tiedostojärjestelmä tukee viittä eri erikoistiedostotyyppiä.
Merkittävin näistä on \emph{symbolinen linkki} (\emph{symbolic link}). (todo).

Muita tuettuja erikoistiedostoja ovat \emph{nimetty putki} (\emph{named pipe}) ja \emph{paikallinen pistoke} (\emph{domain socket}).
Kumpikaan näistä ei persistoi mitään dataa levylle,
vaan niitä käytetään Unix-sovellusohjelmoinnissa mekanismina \emph{prosessien väliseen kommunikointiin} (\emph{IPC}, \emph{Inter-Process Communication}).
Periaatteessa siis vastaava toiminnallisuus voitaisiin toteuttaa käyttöjärjestelmään täysin tiedostojärjestelmästä riippumattomasti,
mutta tämä Unixin tapa tuoda IPC-mekanismit ikään kun tiedostojärjestelmäobjekteiksi mahdollistaa niiden käsittelyn samoilla työkaluilla ja rajapinnoilla kuin tavallisia tiedostoja.
Esimerkiksi aiemmin esitellyt tiedostojen käyttöoikeudet toimivat nimetyille putkille ja paikallisille pistokkeille täsmälleen samoilla tavoilla kuin muillekin tiedostoille.

\subsection{Tiedoston avaus ja sulkeminen}
Tiedoston avaus tapahtuu \texttt{open}-funktiolla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html#tag_16_357
\begin{minted}{c}
int open(const char *path, int oflag, ...);
\end{minted}
%
Parametri \texttt{path} kertoo avattavan tiedoston polku merkkijonona
ja parametri \texttt{oflag} sisältää lippuja jotka määräävät miten tiedosto avataan.
Yksi lipuista \texttt{O\_RDONLY}, \texttt{O\_WRONLY} ja \texttt{O\_RDWR} on pakko antaa.
Ne määräävät avataanko tiedosto vain lukua, vain kirjoitusta tai sekä lukua että
kirjoitusta varten.
Muita mahdollisia lippuja on esimerkiksi \texttt{O\_TRUNC},
joka tyhjentää (\emph{truncate}) tiedoston sisällön.
Mikäli lippu \texttt{O\_CREAT} on annettu,
tiedosto luodaan jos sitä ei ollut aikaisemmin olemassa.
Tällöin kolmas parametri määrittelee luodun tiedoston oikeudet.
Funktio palauttaa onnistuessaan \texttt{int}-tyyppisen \emph{tiedostokahvan},
joka viittaa kyseiseen avattuun tiedostoon.
Tiedostokahvat ovat prosessikohtaisia,
eli yrittämällä lukea samalla tiedostokahvan numeerisella arvolla
jossakin toisessa prosessissa tapahtuu jotain odottamatonta.
Avattu tiedostokahva suljetaan \texttt{close}-funktiolla,
jolle annetaan auki oleva tiedostokahva ainoana parametrina:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html#tag_16_67
\begin{minted}{c}
int close(int fildes);
\end{minted}

\subsection{Tiedoston luku ja kirjoitus}

Tiedostosta luku ja tiedostoon kirjoitus tapahtuu ohjelmoijan näkökulmasta suhteellisen
samalla tavalla, funktioilla \texttt{read} ja \texttt{write}:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html#tag_16_474
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html#tag_16_685
\begin{minted}{c}
ssize_t read(int fildes, void *buf, size_t nbyte);
ssize_t write(int fildes, const void *buf, size_t nbyte);
\end{minted}
%
Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
\texttt{buf} on osoitin \texttt{nbyte} tavun kokoiseen puskuriin johon
luetaan tai josta kirjoitetaan.
Kerralla kirjoitettavan tai luettavan datan määrä voi olla mielivaltaisen kokoinen,
vaikka taustalla oleva media tukisi vain esimerkiksi 512 tavun kokoisen sektorin lukemista tai kirjoittamista.
Tämä on yksi tapa jolla tiedostojärjestelmä abstraktoi laitteistoa.
Onnistuessaan funktiot palauttavat kuinka monta tavua luettiin tai kirjoitettiin.
Paluuarvo voi siis olla pienempi kuin mitä ohjelma pyysi lukemaan tai kirjoittamaan,
esimerkiksi jos kirjoittaessa levy täyttyi kesken tai luettaessa
tiedosto loppui kesken.

Jokaisella tavalliseen tiedostoon viittaavalla tiedostokahvalla on sijainti tavuina missä kohtaa tiedostoa ollaan ja josta lukeminen tai kirjoittaminen aloitetaan.
Tiedostoa avatessa tiedostokahvan sijainti on normaalisti tiedoston alussa ja luku- ja kirjoitusoperaatiot onnistuessaan sijainti tiedostossa siirtyy eteenpäin paluuarvon verran.
Tiedostokahvan sijaintia tiedostossa voi siirtää \texttt{lseek()}-kutsulla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html#tag_16_310
\begin{minted}{c}
off_t lseek(int fildes, off_t offset, int whence);
\end{minted}
Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
Kolmas parametri \texttt{whence} kertoo miten \texttt{offset}-parametri tulkitaan.
Sallittuja arvoja ovat vakiot \texttt{SEEK\_SET}, \texttt{SEEK\_CUR} ja \texttt{SEEK\_END},
jotka tarkoittavat vastaavasti että tiedostokahvan sijainniksi asetetaan \texttt{offset},
että tiedostokahvan sijaintia siirretään eteenpäin \texttt{offset} tavua ja
että tiedostokahvan sijainniksi asetetaan \texttt{offset} tavua eteenpäin laskien tiedoston lopusta.
Onnistuessaan \texttt{lseek()}-kutsu palauttaa sijainnin johon siirryttiin.
Sijainnin voi siis selvittää siirtymättä tiedostossa kutsulla \texttt{lseek(fd, 0, SEEK\_CUR)}.

Unix-tiedostojärjestelmät tukevat \emph{harvoja} (\emph{sparse}) tiedostoja,
eli tiedostoissa voi olla kohtia jossa niille ei ole varattu levytilaa mutta niistä lukeminen onnistuu ja palauttaa nollatavuja.
Harvojen tiedostojen tekeminen onnistuu \texttt{lseek()}-funktion avulla siirtymällä tiedostossa eteenpäin kohtaan johon ei ole kirjoitettu mitään.
Esimerkiksi kirjoittamalla ensin 32 kilotavua,
siirtymällä eteenpäin 32 kilotavua kutsulla \texttt{lseek(fd, 32768, SEEK\_CUR)},
ja kirjoittamalla toiset 32 kilotavua pitäisi lopputuloksena olla tiedosto jonka koko on 96 kilotavua mutta vie vain 64 kilotavua levytilaa.
Tiedoston metadatan voi lukea \texttt{fstat()}- tai \texttt{stat()}-funktioilla.

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html#tag_16_173
% myös: int lstat(const char *path, struct stat *buf);
\begin{minted}{c}
int fstat(int fildes, struct stat *buf);
int stat(const char *path, struct stat *buf);
\end{minted}
%
Onnistuessaan funktio täyttää \texttt{struct stat}-tietueen,
josta löytyy muun muassa seuraavia kenttiä:
%
\begin{itemize}
    \item Kenttä \texttt{mode\_t st\_mode} kertoo tiedoston tyypin (tavallinen tiedosto, hakemisto, yms.) ja käyttöoikeudet.
    \item Kenttä \texttt{size\_t st\_size} kertoo tiedoston koon tavuina.
    \item Kenttä \texttt{blkcnt\_t st\_blocks} kertoo tiedoston viemän tilan 512 tavun yksiköissä.
    \item Kentät \texttt{uid\_t st\_uid} ja \texttt{gid\_t st\_gid} kertovat tiedoston omistavan käyttäjän sekä ryhmän tunnuksen numeerisen arvon.
    \item Kentät \texttt{st\_atim}, \texttt{st\_mtim} ja \texttt{st\_ctim} kertovat tiedoston aikaleimat.
\end{itemize}

% \begin{minted}{c}
%         mode_t st_mode          Mode of file (see below).
%         uid_t st_uid            User ID of file.
%         gid_t st_gid            Group ID of file.
%         struct timespec st_atim Last data access timestamp.
%         struct timespec st_mtim Last data modification timestamp.
%         struct timespec st_ctim Last file status change timestamp.
% \end{minted}
%
% dev_t st_dev            Device ID of device containing file
% ino_t st_ino            File serial number.
% nlink_t st_nlink        Number of hard links to the file.
% dev_t st_rdev           Device ID (if file is character or block special).
% off_t st_size           For regular files, the file size in bytes.
%                         For symbolic links, the length in bytes of the
%                         pathname contained in the symbolic link.
% blksize_t st_blksize    A file system-specific preferred I/O block size
%                         for this object. In some file system types, this
%                         may vary from file to file.
% blkcnt_t st_blocks      Number of blocks allocated for this object.
%

Tiedoston, mutta ei hakemistoa, voi poistaa \texttt{unlink()}-funktiolla.
Hakemiston poistamiseen käytetään funktiota \texttt{rmdir()} ja poistettavan hakemiston täytyy olla tyhjä:
%
\begin{minted}{c}
int unlink(const char *path);
int rmdir(const char *path);
\end{minted}
%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html#tag_16_635
Tiedoston voi uudelleennimetä \texttt{rename()}-funktiolla:
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html#tag_16_487
%
\begin{minted}{c}
int rename(const char *old, const char *new);
\end{minted}
%
Uudelleennimeämisen ei tarvitse tapahtua saman hakemiston sisällä,
vaan esimerkiksi \texttt{rename("/tmp/file.tmp", "/home/foo/file.txt")} on sallittua,
mutta sekä lähde- että kohdepolun täytyy sijaita samalla tiedostojärjestelmällä.
Kohdepolku voi viitata myös olemassa olevaan tiedostoon,
jolloin kyseinen olemassa oleva tiedosto poistetaan operaation yhteydessä ikään kuin \texttt{unlink()}-kutsua olisi käytetty ennen uudelleennimeämistä.
% Kaikissa tapauksissa operaatio on atominen.

%%% % FIXME: hard links
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/chmod.html#tag_16_58
%%% \begin{minted}{c}
%%% int chmod(const char *path, mode_t mode);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html#tag_16_59
%%% \begin{minted}{c}
%%% int chown(const char *path, uid_t owner, gid_t group);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html#tag_16_293
%%% \begin{minted}{c}
%%% int link(const char *path1, const char *path2);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html#tag_16_635
%%% \begin{minted}{c}
%%% int unlink(const char *path);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html#tag_16_475
%%% \begin{minted}{c}
%%% struct dirent *readdir(DIR *dirp);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html#tag_16_476
%%% \begin{minted}{c}
%%% ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html
%%% \begin{minted}{c}
%%% int ftruncate(int fildes, off_t length);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdopendir.html#tag_16_127
%%% \begin{minted}{c}
%%% DIR *opendir(const char *dirname);
%%% \end{minted}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/closedir.html
%%% \begin{minted}{c}
%%% int closedir(DIR *dirp);
%%% \end{minted}

\section{POSIX-rajapintojen kaatumisturvallinen käyttö}
\label{ChapPosixDataConsistency}
Tietokoneiden massamuistit ovat tyypillisesti keskusmuistia merkittävästi hitaampia lukea ja kirjoittaa.
Tyypillinen tapa parantaa tiedostojärjestelmän suorituskykyä onkin käyttää osaa keskusmuistista välimuistina tiedostojärjestelmälle,
ja POSIX-standardi antaakin tiedostojärjestelmätoteutuksille reilusti vapauksia erilaisten välimuistien käyttöön.
Tämä kuitenkin hankaloittaa kaatumistilanteita kestävien sovellusten toteuttamista.
Tarkastellaankin seuraavaksi POSIXin tarjoamia rajapintoja tiedostojärjestelmän välimuistien hallintaan sekä muita sovellusohjelmoijan kannalta huomioon otettavia seikkoja.

% ??? needed?
% Muun muassa Linux-tiedostojärjestelmät hyödyntävätkin levyvälimuisteja merkittävissä määrin,
% mikä nähdään myöhemmin luvussa~\ref{ChapExt2Crash}.
\subsection{Tiedostojärjestelmien levyvälimuistit}

Erinäiset levyvälimuistit olivat käytössä jo hyvin varhain Unixissa.
Jo Ritchien ja Thompsonin alkuperäisestä ``The UNIX time-sharing system''~\cite{UnixPaper}-artikkelista vuodelta 1974 löytyy lyhyt selostus Unixin \emph{lohkovälimuistista} (\emph{buffer cache}).
Lohkovälimuistin toiminta levyltä luettaessa esimerkiksi \texttt{read()}-kutsun yhteydessä on yksinkertainen:
välimuistista etsitään lohkonumerolla hakemalla lohkon sisältö.
Pelkkien levylukujen vieminen välimuistin kautta ei vielä näy sovellusohjelmoijalle mitenkään,
mutta lohkovälimuisti joka toimii myös levykirjoituksille tuottaa haasteita.
Käytännössä tämä tarkoittaa että \texttt{write()}-kutsun yhteydessä tehty tiedostoon kirjoitus ei päädy levylle asti välittömästi,
vaan sovellusohjelman kirjoittama data ainoastaan kopioidaan levyvälimuistin puskuriin sekä merkitään kyseinen puskuri kirjoitettavaksi myöhemmin levylle~\cite{UnixPaper}.
Itse puskureiden kirjoitus levylle tapahtuu taustalla tietyin väliajoin,
esimerkiksi Unixin alkuaikoina 30 sekunnin välein ~\cite{SpriteRosenblumThesis}.
Moderneissa Unix-järjestelmissä levyvälimuistien käyttö on laajennettu koskemaan myös hakemistoja ja tiedostojen metadataa.
%Kokonaisuudessaan tästä aiheutuu seuraavia pulmia jotka sovelllusohjelmoijan täytyy ottaa huomioon:
%\begin{itemize}
%    \item{Muokkaukset  \emph{pysyvä} (\emph{durable}) operaatio.}
%\end{itemize}
%
%
%tiedoston metadataa muokkaavat operaatiot,
%mukaan lukien aikaleimojen päivitykset eivät välttämättä päädy levylle asti tiedostojärjestelmäkutsun palatessa.
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html
Levyvälimuistin hallintaan löytyy POSIXissa kaksi keskeistä funktiota~\cite{PosixSpec}:
\begin{minted}{c}
int fdatasync(int fildes);
int fsync(int fildes);
\end{minted}
%
Operaatio \texttt{fdatasync()} pakottaa parametrina annettua tiedostokahvaa \texttt{fildes} vastaavan tiedoston levyvälimuistin kirjoittamisen.
Funktiokutsu ei palaa kunnes data on turvallisesti kirjoitettu levylle.
\texttt{fdatasync()}-kutsu ei vaikuta tiedoston metadataan muuten kuin että kutsun onnistuessa taataan että tiedostoon tähän asti tehdyt kirjoitukset ovat luettavissa kaatumisen jälkeenkin.
Käytännössä käyttäjän näkökulmasta tämä takaa vain että tiedoston koko on ajan tasalla.
Funktio \texttt{fsync()} on vahvempi versio \texttt{fdatasync()}:stä joka lisäksi pakottaa kaiken tiedoston viittaavan inoden metadatan kirjoitettavan levylle.
Lisäksi on varmistettava erikseen että tiedoston inodeen viittaavat tiedostonimet ovat kirjoitettu pysyvästi levylle.
Tämä tapahtuu kutsumalla \texttt{fsync()}-funktiota hakemistolle jossa tiedostonimi sijaitsee.

\subsection{Esimerkki tiedoston tallentamisesta tekstieditorissa}
Tarkastellaan nyt esimerkin avulla miten POSIXin levyvälimuistin käsittelyfunktioilla voidaan toteuttaa kaatumisturvallisia sovelluksia.
Melkeinpä yksinkertaisin mahdollinen sovellus jossa kaatumisturvallisuus on tärkeää on perus tekstieditori.
Tyypillinen käyttötapaus on, että käyttäjä avaa editorissa tiedoston, muokkaa sitä, ja tallentaa muokatun sisällön samalla nimellä alkuperäisen tiedoston päälle.
Luotettavan editorin kuuluu tehdä tiedoston tallennus atomisesti,
eli kaatumistilanteen sattuessa joko tiedoston täytyy sisältää joko uusi tai alkuperäinen sisältö.
Lisäksi voidaan odottaa tallennusoperaation olevan \emph{pysyvä} (\emph{durable}),
eli editorin ilmoittaessa tallennuksen olevan valmis täytyy tiedoston uuden version olla kirjoitettuna levylle.
Suoraviivaisin tapa toteuttaa tallennus on kirjoittaa koko tiedosto uudelleen seuraavasti:

\begin{minted}[linenos]{c++}
int fd = open("/mnt/usb/file.txt", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
close(fd);
printf("Tallennus valmis.\n");
\end{minted}
%
Tämä sekvenssi operaatioita ei kuitenkaan ole turvallinen vaikka edes tiedostojärjestelmän kaatumista ei tapahtuisi.
Jo pelkkä tekstieditorin kaatuminen \texttt{open()}- ja \texttt{write()}- kutsujen välissä jättää jäljelleen tyhjän tiedoston.
Yksinkertainen yritys välttyä tältä ongelmalta on ensin kirjoittaa tallennettava sisältö väliaikaistiedostoon,
ja hyödyntää \texttt{rename()}-kutsun kykyä atomisesti korvata tiedosto toisella:

\begin{minted}[linenos]{c++}
int fd = open("/mnt/usb/file.txt.tmp", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
close(fd);
rename("/mnt/usb/file.txt.tmp", "/mnt/usb/file.txt");
printf("Tallennus valmis.\n");
\end{minted}
%
Tämä versio sietää sovelluksen kaatumisen mutta ei toimi tiedostojärjestelmän kaatumistilanteessa,
sillä mikään ei takaa että \texttt{write()}-kutsun tekemät kirjoitukset ja tiedoston uudelleennimeäminen \texttt{rename()}-kutsulla kirjoitettaisiin levylle edellä mainitussa järjestyksessä.
Tiedostojärjestelmän kaatumistilanteessa tyhjä tai osittain kirjoitettu tiedosto on siis edelleen mahdollinen.
Myöskään operaation pysyvyydellä ei ole mitään takeita,
vaan käyttäjä voi nähdä \texttt{Tallennus valmis.}-tulosteen ilman että levylle on tehty yhtäkään kirjoitusta.
Sen sijaan täysin kaatumisturvallinen tallennus on toteutettu Gedit-tekstieditorissa seuraavasti~\cite{OptimisticCrashConsistency}:

\begin{minted}[linenos]{c++}
int fd = open("/mnt/usb/file.txt.tmp", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
fsync(fd);
close(fd);
rename("/mnt/usb/file.txt.tmp", "/mnt/usb/file.txt");
int dfd = open("/mnt/usb", O_DIRECTORY | O_RDONLY);
fsync(dfd);
close(dfd);
printf("Tallennus valmis.\n");
\end{minted}
%
\texttt{write()}-ja \texttt{rename()}-kutsujen väliin on siis lisätty yksi \texttt{fsync()}-kutsu riville 3 takaamaan että näiden operaatioiden järjestys ei vaihdu levylle kirjoittaessa.
Tämä tekee tiedoston tallennusoperaatiosta atomisen mutta ei vielä takaa pysyvyyttä.
Pysyvyyteen vaaditaan \texttt{fsync()}-operaation suoritus kohdetiedoston sisältävälle hakemistolle rivillä 7,
mikä takaa että \texttt{rename()}-kutsun tekemän muutokset itse hakemiston sisällölle ovat päätyneet levylle.

\section{POSIX-tiedostojärjestelmien kaatumistilanteet käytännössä}
\label{ChapPosixSafetyStudy}
%Edellisen luvun esimerkistä nähtiin miten yksinkertaisenkin koostetun tiedostojärjestelmäoperaation toteuttaminen kaatumisturvallisesti on verrattaen haastavaa,
%koska POSIX-standardi tarjoaa tiedostojärjestelmätoteutuksille merkittävät vapaudet uudelleen järjestellä tai lykätä levykirjoitusten tekemistä ellei sitä erikseen pakoteta \texttt{fsync()}- tai \texttt{fdatasync()}-kutsuja käyttämällä.
Edellisen luvun esimerkistä nähtiin miten POSIX-standardin sallimat levyvälimuistit hankaloittavat merkittävästi kaatumisturvallisen sovelluksen toteuttamista.
Tarkastellaankin seuraavaksi levyvälimuistien vaikutusta kaatumistilanteisiin tarkemmin.
tutkimusta siitä millaisia vaikutuksia kaatumistilanteilla on tosimaailman tiedostojärjestelmille ja sovelluksille.
% Tutkimuksesta selviää myös joidenkin avoimen lähdekoodin sovelluksien kaatumisturvallisuus.
%Onkin siis mielekästä tutkia kokeellisesti miten kaatumistilanteet vaikuttavat tosimaailman sovelluksiin ja tiedostojärjestelmiin.
%Koska sovellusohjelmoijan täytyy erikseen osata käyttää POSIX-rajapintoja oikein jotta sovelluksesta saadaan kaatumisturvallinen,
%herääkin kysymys, että kuinka moni sovellus ylipäätään on pyritty toteuttamaan kaatumisturvallisesti ja että onko niiden toteutus oikein.
%Tiedostojärjestelmätoteutusten kannalta taas on relevanttia selvittää miten eri tiedostojärjestelmät käytännössä käyttäytyvät kaatumistilanteessa sovellusohjelmoijan näkökulmasta.
%Molempia näistä aiheista on tutkittu kokeellisesti artikkelissa ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''~\cite{PosixDataConsistency} vuodelta 2014,
%joten tarkastellaan aiheita seuraavissa aliluvuissa.

\subsection{Tutkimus tiedostojärjestelmien käyttäytymisestä kaatumistilanteessa}
POSIX-standardi tarjoaa siis tiedostojärjestelmätoteutukselle merkittävät vapaudet esimerkiksi uudelleen järjestellä tai lykätä levykirjoitusten tekemistä suorituskyvyn parantamiseksi,
ellei sovellusohjelma ole erikseen pakottanut sitä \texttt{fsync()}- tai \texttt{fdatasync()}-kutsuja käyttämällä.
Itse tiedostojärjestelmätoteutuksen ei tietenkään ole mikään pakko hyödyntää näitä vapauksia,
joten herääkin kysymys ilmeneekö tiedostojärjestelmien käyttäytymisessä eroavaisuuksia.
Tätä aihetta on tutkittu kokeellisesti ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''\cite{PosixDataConsistency}-artikkelissa,
jossa on vertailtu kuutta eri Linux-tiedostojärjestelmää: \texttt{btrfs}, \texttt{ext2}, \texttt{ext3}, \texttt{ext4}, \texttt{reiserfs} sekä \texttt{xfs}.
Lisäksi useimpia tiedostojärjestelmiä testattiin eri tiedostojärjestelmäkohtaisilla optioilla,
joten kombinaatioita saatiin yhteensä 16 kappaletta.

Tiedostojärjestelmien vertailua varten määriteltiin \emph{persistenssiominaisuuden} (\emph{persistence property}) käsite.
Persistenssiominaisuudet ovat käytöksiä joita ilmenee tiedostojärjestelmän kaatumistilanteessa,
jotka jakautuvat kohteen kategoriaan: operaatioiden atomisuuteen ja operaatioiden uudelleenjärjestelyyn.
Esimerkiksi \texttt{write()}-kutsun osalta voidaan tutkia tapahtuuko kirjoitus atomisesti kaatumistilanteen sattuessa ja voiko kirjoitus tapahtua eri järjestyksessä suhteessa johonkin toiseen tiedostojärjestelmäkutsuun.
Persistenssiominaisuuksien testaus tehtiin BOB-työkalulla (\emph{Block Order Breaker}),
Sen periaatteena on nauhoittaa testattavan tiedostojärjestelmän tekemiä levykirjoituksia lokitiedostoon,
josta voidaan jälkikäteen käydä läpi kaikki mahdolliset kaatumistilanteet läpi.
Nyt kaatumistilanteista voidaan etsiä vastaesimerkkejä joissa testattava persistenssiominaisuus ei päde.
BOB:n voidaan siis vain todeta jonkin persistenssiominaisuuden paikkaansa pitämättömyys, mutta ei toisinpäin.

\subsection{Tutkittujen tiedostojärjestelmien persistenssiominaisuudet}
\newcommand{\atY}{$\bullet$}
\newcommand{\atN}{{\small $\times$}}

\newcommand{\hdr}[1]{\rotatebox[origin=l]{90}{\small \texttt{#1}}}
% ei atomisuutta    x  \atN
% 1 sektori        1/3 \atS
% 1 lohko          2/3 \atB
% mielivaltainen   3/3 \atF
\pgfmathsetlengthmacro\sideA{0.8mm}
\pgfmathsetlengthmacro\sideB{2 * \sideA}
\pgfmathsetlengthmacro\sideC{3 * \sideA}
\def\side{1}
%\newcommand{\atN}{\tikz{\draw       (0,0) rectangle (\sideA, \sideA); \draw       (\sideA,0) rectangle (\sideB, \sideB); \draw       (\sideB,0) rectangle (\sideC, \sideC); }}
\DeclareRobustCommand{\atS}{\tikz{\draw[fill] (0,0) rectangle (\sideA, \sideA); \draw       (\sideA,0) rectangle (\sideB, \sideB); \draw       (\sideB,0) rectangle (\sideC, \sideC); }}
\DeclareRobustCommand{\atB}{\tikz{\draw[fill] (0,0) rectangle (\sideA, \sideA); \draw[fill] (\sideA,0) rectangle (\sideB, \sideB); \draw       (\sideB,0) rectangle (\sideC, \sideC); }}
\DeclareRobustCommand{\atF}{\tikz{\draw[fill] (0,0) rectangle (\sideA, \sideA); \draw[fill] (\sideA,0) rectangle (\sideB, \sideB); \draw[fill] (\sideB,0) rectangle (\sideC, \sideC); }}


Seuraavien operaatioiden osalta tutkittiin niiden atomisuutta:
%
\begin{itemize}
    \item{Tiedoston olemassa olevan sisällön ylikirjoitus erikokoisilla \texttt{write()}-kutsulla.}
    \item{Sisällön lisääminen tiedoston loppuun erikokoisilla \texttt{write()}-kutsulla.}
    \item{Hakemisto-operaatioita, kuten \texttt{link()}, \texttt{unlink()} ja \texttt{rename()}.}
\end{itemize}
%
\texttt{write()}-kutsun tapauksessa on siis erikseen tutkittu tilanteita jossa tiedoston pituus kasvaa ja tilanteita jossa pelkästään ylikirjoitetaan olemassa olevaa sisältöä.
Lisäksi molempia kokeiltiin vaihtelevilla kirjoitettavan datan määrillä,
joista mielekkäitä tilanteita ovat levyn sektorin koon (tai vähemmän) verran, yhden tiedostojärjestelmälohkon sekä tätä suuremmat määrät.

\newcommand{\ordY}{$\bullet$}
\newcommand{\ordN}{{\small $\times$}}
\begin{table}[h!]
\label{TabPersistencePropsAtomicity}
\bgroup
%\def\arraystretch{0.9}
\setlength{\tabcolsep}{0.3em}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
    & \hdr{ext2} & \hdr{ext2-sync} & \hdr{ext3-writeback} & \hdr{ext3} & \hdr{ext3-datajournal} & \hdr{ext4-writeback} & \hdr{ext4} & \hdr{ext4-nodelalloc} & \hdr{ext4-datajournal} & \hdr{btrfs} & \hdr{xfs} & \hdr{xfs-wsync} & \hdr{reiserfs-nolog} & \hdr{reiserfs-writeback} & \hdr{reiserfs} & \hdr{reiserfs-datajournal} \\ \hline
    ylikirjoitus          & \atS & \atS & \atS & \atS & \atB & \atS & \atS & \atS & \atB & \atB & \atS & \atS & \atS & \atS & \atS & \atB \\
    loppuun lisäys        & \atN & \atS & \atN & \atB & \atB & \atN & \atB & \atB & \atB & \atB & \atB & \atB & \atS & \atN & \atS & \atB \\
    hakemisto-operaatiot  & \atN  & \atN  & \atY & \atY & \atY & \atY & \atY & \atY & \atY & \atY & \atY & \atY & \atN  & \atY & \atY & \atY \\
\end{tabular}
\egroup
\caption{Atomisuutta koskevat persistenssiominaisuudet eri tiedostojärjestelmillä~\cite[taulukko 1, s. 3]{PosixDataConsistency}.
    \texttt{write()}:n kohdalla \atN $ = $ ei atominen millään datamäärillä,
    \atS~$ = $ atominen korkeintaan levysektorin kokoisilla kirjoituksilla,
    \atB~$ = $ atominen korkeintaan tiedostojärjestelmälohkon kokoisilla kirjoituksilla,
    ja \atF~$ = $ atominen millä tahansa datamäärillä.
    Muiden operaatioiden osalta \atY~ilmaisee atomista operaatiota ja \atN~atomisuuden puutetta.
}
\end{table}
%
Taulukossa~\ref{TabPersistencePropsAtomicity} on tulokset tutkituista atomisuuteen liittyvistä persistenssiominaisuuksista.
\texttt{write()}-kutsun osalta ainoa kaikissa tiedostojärjestelmissä atomiseksi havaittu operaatio on yksittäisen levysektorin kokoinen ylikirjoitus.
Tämä on ongelmallista, koska nyt tiedostojärjestelmä ei enää toimikaan kunnollisena abstraktiona laitteistolle.
Tiedoston loppuun tapahtuu tiedostojärjestelmän sisällä tyypillisesti kahdesta alioperaatiosta: ensin tiedostolle varataan lisää datalohkoja ja kasvatetaan sen kokoa, jonka jälkeen lisättävä data kirjoitetaan.
Tämä toteutusyksityiskohta ilmenee siten ettei tiedoston loppuun lisääminen pienilläkään datamäärillä välttämättä ole atominen \texttt{ext2}, \texttt{ext3-writeback}, \texttt{ext4-writeback} ja \texttt{reiserfs-writeback}-tiedostojärjestelmissä.
Voidaan päätyä tilanteeseen jossa tiedoston kokoa on ehditty kasvattamaan mutta itse dataa ei ole vielä kirjoitettu,
jolloin kaatumistilanteen jälkeen tiedoston lopusta voidaan havaita nollatavuja lisätyn datan sijaan.

Toinen tutkittu persistenssiominaisuuksien kategoria on tiedostojärjestelmäoperaatioiden järjestyksen vaihtuminen levylle kirjoittaessa.
Tilanteissa jossa ohjelmakoodissa tehdään peräkkäin toisistaan riippumattomat operaatiot
\begin{minted}{c}
    operaatio1();
    operaatio2();
\end{minted}
mutta kaatumistilanteen jälkeen havaitaan tilanne jossa ainoastaan \texttt{operaatio2()} on suoritettu loppuun,
todetaan operaatioiden uudelleenjärjestymisen olevan mahdollista \texttt{operaatio1()}:n ja \texttt{operaatio2()}:n välillä.

\begin{table}[h!]
\label{TabPersistencePropsOrdering}
\bgroup
%\def\arraystretch{0.9}
\setlength{\tabcolsep}{0.3em}
\begin{tabular}{r|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
    & \hdr{ext2} & \hdr{ext2-sync} & \hdr{ext3-writeback} & \hdr{ext3} & \hdr{ext3-datajournal} & \hdr{ext4-writeback} & \hdr{ext4} & \hdr{ext4-nodelalloc} & \hdr{ext4-datajournal} & \hdr{btrfs} & \hdr{xfs} & \hdr{xfs-wsync} & \hdr{reiserfs-nolog} & \hdr{reiserfs-writeback} & \hdr{reiserfs} & \hdr{reiserfs-datajournal} \\ \hline
    ylikirjoitus                                                   & \ordN & \ordY & \ordN & \ordN & \ordY & \ordN & \ordN & \ordN & \ordY & \ordY & \ordN & \ordN & \ordN & \ordN & \ordN & \ordY \\
    \texttt{\{}lisäys\texttt{;}uudelleennimeäminen\texttt{\}}      & \ordN & \ordY & \ordN & \ordY & \ordY & \ordN & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordN & \ordN & \ordY & \ordY \\
    \texttt{\{open(O\_TRUNC);}lisäys\texttt{\}}                    & \ordN & \ordY & \ordN & \ordY & \ordY & \ordN & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordN & \ordN & \ordY & \ordY \\
    %lisäys saman tiedoston sisällä                                 & \ordN & \ordY & \ordN & \ordY & \ordY & \ordN & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordN & \ordN & \ordY & \ordY \\
    lisäys tiedoston loppuun                                       & \ordN & \ordY & \ordN & \ordY & \ordY & \ordN & \ordN & \ordY & \ordY & \ordN & \ordN & \ordY & \ordN & \ordN & \ordY & \ordY \\
    hakemisto-operaatio                                            & \ordN & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordY & \ordN & \ordY & \ordY & \ordY & \ordN & \ordY & \ordY \\
\end{tabular}
\egroup
    \caption{Uudelleenjärjestelyä koskevat peristenssioperaatiot eri tiedostojärjestelmillä~\cite[taulukko 1, s. 3]{PosixDataConsistency}.
             \ordN-symbolilla merkityt operaatiot saatetaan kirjoittaa levylle eri myöhemmin kuin sitä ohjelmakoodissa seuraavat operaatiot.
             \ordY~tarkoittaa järjestyksen säilyvän.
            }
\end{table}
Taulukossa~\ref{TabPersistencePropsOrdering} on listattu operaatioita joiden kirjoitusjärjestys saattaa vaihtua myöhempien tiedostojärjestelmäoperaatioiden kanssa.
Merkintä \texttt{\{}$X$\texttt{;}$Y$\texttt{\}} tarkoittaa että
operaatiot $X$ ja $Y$ ovat perättäisiä operaatioita samalle tiedostolle, ja että kummankaan operaation järjestys ei vaihdu myöhempien operaatioiden kanssa.
Uudelleenjärjestelyiden suhteen jotkut tiedostojärjestelmät on erikseen mahdollista konfiguroida tekemään kaikki kirjoitukset järjestyksessä:
\texttt{ext2}:n tapauksessa optiolla \texttt{sync} ja journaloivien tiedostojärjestelmien kohdalla optiolla \texttt{datajournal}.
Toisaalta paremman suorituskyvyn omaava \texttt{writeback}-optio aiheuttaa enemmän mahdollisia operaatioiden välisiä uudelleenjärjestelyjä.

%
% TODO for next release
% Jo varsin yksinkertainen operaatio, tiedoston loppuun kirjoittaminen tuottaa erilaisia tuloksia eri tiedostojärjestelmäkonfiguraatioilla
% sekä myös kirjoitettavan datan määrä vaikuttaa tulokseen.
% Jo yhden sektorin (tai vähemmän) lisääminen tiedostoon ei ole atominen operaatio muutamalla tiedostojärjestelmällä: \texttt{ext2} sekä
% \texttt{ext3}, \texttt{ext4} ja \texttt{reiserfs} mikäli käytetään writeback-journalointitilaa.
%

%Kuten edellisessä luvussa nähtiin,
%jo pelkästään Linuxin mukana tulevat tiedostojärjestelmät omaavat erilaisia persistenssiominaisuuksia,
%jotka saattoivat riippua myös tiedostojärjestelmälle annetuista optioista.
%Tästä seuraakin suoraan kysymys siitä kuinka nämä erot vaikuttavat sovellusohjelmiin,
%ja onkin samalla toinen ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''-artikkelin tutkima aihe.

\subsection{Sovellusten päivitysprotokollat}

Aiemmin luvussa~\ref{ChapPosixDataConsistency} nähtiin miten tekstieditorin tiedoston tallennuksesta saatiin tehtyä kaatumisturvallinen POSIX-tiedostojärjestelmäoperaatioita koostamalla.
Tässä kyseisessä käyttötapauksessa päästiin haluttuun lopputulokseen varsin suoraviivaisella toteutuksella, jossa yksinkertaisesti kirjoitettiin koko tiedosto uudestaan.
Muuntyyppisillä sovelluksilla voi olla huomattavastikin monimutkaisempia vaatimuksia.
Esimerkiksi SQL-kyselykielen perustoiminnallisuuksiin kuuluvat transaktiot,
joiden avulla relaatiotietokannassa voidaan atomisesti päivittää useita, mahdollisesti eri tauluihin kuuluvia rivejä atomisesti~\cite{DatabaseFundamentals}.
Jo yksittäiset tietokannat voivat nykyään kuitenkin olla useiden teratavujen kokoisia ja käsitellä useita toisistaan riippumattomia kirjoitustransaktioita rinnakkain~\cite{DatabaseFundamentals}.
Selvästikin kelvollisen suorituskyvyn saavuttamiseksi koko tietokannan uudelleen kirjoitus joka transaktion yhteydessä ei tule kysymykseen tällaisessa käyttötapauksessa,
vaan tietokannan ohjelmoijan täytyy itse suunnitella jokin mekanismi jolla kaatumistilanteessa voidaan palauttaa tietokannan tila konsistentiksi.
Näitä sovellusten käyttämiä mekanismeja kutsutaan \emph{päivitysprotokolliksi} (\emph{update protocol})~\cite{PosixDataConsistency}.
%%% Erinäisten sovellusten päivitysprotokollien tutkimista varten kehitetty työkalu ALICE (\emph{Application-Level Intelligent Crash Explorer}) toimii samantyyppisellä periaatteella kuin aiemmin kuvattu BOB:
%%% testattavan sovelluksen tekemät tiedostojärjestelmäkutsut nauhoitetaan lokitiedostoon,
%%% joista voidaan jälkikäteen simuloida mahdollisia kaatumistilanteita.
%%% Big FIXME...

Tarkastellaan nyt lähemmin ALICEn löytämää haavoittuvuutta SQLite-tietokantakirjastosta.
SQLite on laajasti käytetty SQL-kyselykieleen pohjautuva tietokanta,
joka tarjoaa täyden tuen SQL-kielen transaktioille.
Transaktionaalisten päivitysten tekemiseen SQLite käyttää sisäisesti joko historiallista rollback journal-menetelmää tai uudempaa Write-Ahead Logging-menetelmää~\cite{SqliteAnalysis},
missä käytettävä menetelmä on käyttäjän valittavissa.
ALICEn löytävä haavoittuvuus koskee yksinomaan rollback journal-tilaa,
jonka päivitysprotokolla on seuraavanlainen~\cite{PosixDataConsistency}:
% Fig 4(F)

\begin{enumerate}
    \item{\texttt{creat(journal)}}
    \item{$n \times \texttt{append(journal)}$}
    \item{\texttt{fsync(journal)}}
    \item{\texttt{fsync(parent-dir)}}
    \item{\texttt{write(journal)}}
    \item{\texttt{fsync(journal)}}
    \item{\texttt{write(db)}}
    \item{\texttt{fsync(db)}}
    \item{\texttt{unlink(journal)}}
    \item{\texttt{stdout(done)}}
\end{enumerate}

Transaktion alkaessa luodaan kohdassa 1. tietokantatiedostosta erillinen tiedosto rollback journalille.
Ennen varsinaisen tietokantatiedoston päivitystä kirjoitetaan kohdassa 2 rollback journaliin tieto siitä,
mitä tietokantasivuja transaktiossa ollaan muokkaamassa sekä kunkin muokatun sivun alkuperäinen sisältö.
Kohdissa 3 ja 4 pakotetaan rollback journalin kirjoitus levylle ja että sen hakemistoalkio on pakotettu levylle.
Kohdat 5--6 päivittävät rollback journalin otsakkeeseen, että sen kirjoitus on suoritettu loppuun.
Kohdassa 7 tehdään muutokset itse tietokantaan, ja pakotetaan tietokannan muutosten kirjoitus levylle kohdassa 8.

Mahdollisissa kaatumistilanteissa perusajatuksena on,
että mikäli rollback journal-tiedostoa ei ole tai sen otsakkeen perusteella sitä ei ole kirjoitettu kokonaan loppuun,
on itse tietokanta konsistentissa tilassa ja palautumiseen riittää ainoastaan poistaa mahdollinen osittain kirjoitettu rollback journal.
Muuten palautetaan tietokanta konsistentiksi peruuttamalla rollback journalin 

\begin{table}[h!]
\label{TabAppVulnerabilities}
\bgroup
%\def\arraystretch{0.9}
\setlength{\tabcolsep}{0.3em}
\begin{tabular}{r|c|c|c|c|c|}
             & \hdr{ext3-writeback} & \hdr{ext3} & \hdr{ext3-datajournal} & \hdr{ext4-ordered} & \hdr{btrfs} \\ \hline
    LevelDB 1.10     & 3 & 1 & 1 & 2 & 4 \\
    LevelDD 1.15     & 2 & 1 & 1 & 2 & 3 \\
    LMDB             &   &   &   &   &   \\
    GDBM             & 3 & 3 & 2 & 3 & 4 \\
    HSQLDB           &   &   &   &   & 4 \\
    SQLite-Rollback  & 1 & 1 & 1 & 1 & 1 \\
    SQLite-WAL       &   &   &   &   &   \\
    PostgreSQL       &   &   &   &   &   \\
    HDFS             &   &   &   &   & 1 \\
    ZooKeeper        & 1 & 1 &   & 1 & 1 \\
%Total 16 12 10 17 31
\end{tabular}
\egroup
    \caption{Joidenkin sovellusten haavoittuuvuudet kaatumistilanteissa eri tiedostojärjestelmillä~\cite[taulukko 3(c), s. 11]{PosixDataConsistency}.}
\end{table}

\section{\texttt{ext2}-tiedostojärjestelmä}
\label{ChapExt2Fs}
Edellisissä luvuissa nähtiin sovellusohjelmoijan näkökulmasta millaisia tiedostojärjestelmärajapintoja POSIX-spesifikaatio antaa sovellusten käytettäväksi sekä kuinka niitä täytyy käyttää oikein kaatumisturvallisuuden säilyttämiseksi.
Nyt siirrytään tarkastelemaan miten itse tiedostojärjestelmän pitää toimia jotta kaatumisturvallisuus säilyy koko kokonaisuuden kannalta.
Esimerkiksi aiemmin nähdyn tekstieditoriesimerkin toiminnan kannalta on kriittistä että \texttt{rename()}-kutsu toimii atomisesti,
joten tiedostojärjestelmän täytyy siis pystyä toteuttamaan tämä sekä joitakin muita lupauksia tiedostojärjestelmäkutsujen toiminnasta.
Tässä luvussa vastataan näihin kysymyksiin perehtymällä Linuxin \texttt{ext2}-tiedostojärjestelmän sisäiseen toimintaan ja sen rakenteeseen levyllä.
Tiedostojärjestelmän levyrakenne vaikuttaa olennaisesti siihen minkälaisia epäkonsistenttiuksia tiedostojärjestelmään voi syntyä virhetilanteissa,
joten vahva ymmärrys \texttt{ext2}:n levyformaatista on tarpeen tutkittaessa \texttt{ext2}:n käyttäytymistä kaatumistilanteessa luvussa~\ref{ChapExt2Crash}.
Lisäksi \texttt{ext2}:n levyrakenne on vahvasti BSD-käyttöjärjestelmän Berkeley Fast Filesystem-tiedostojärjestelmän inspiroima~\cite{Ext2Design},
sekä yleisestikin ottaen on varsin suoraviivainen tapa toteuttaa Unix-tyylinen tiedostojärjestelmä,
joten \texttt{ext2}:n ymmärrys auttaa merkittävästi muidenkin saman aikakauden Unix-tyylisten tiedostojärjestelmien ymmärtämisessä.

\subsection{Historia}

\texttt{ext2} (``Second extended filesystem'') on tiedostojärjestelmä joka on luotu jo Linuxin varhaisina aikoina, vuosina 1992--1993~\cite{Ext2Design}.
Alunperin Linuxilla ei ollut omaa varta vasten suunniteltua tiedostojärjestelmää,
vaan se käytti MINIX-käyttöjärjestelmän tiedostojärjestelmää vain koska Linuxin alkuperäinen kehitys oli tehty MINIXillä.
MINIX-tiedostojärjestelmä kuitenkin sisälsi erinäisiä rajoitteita jotka alkoivat haittaamaan.
Esimerkiksi tiedostonimen pituus oli rajoitettu 14 merkkiin ja tiedoston koko 64 megatavuun~\cite{Ext2Design}.
\texttt{ext2} ei ainoastaan korjaa näitä puutteita,
mutta on lisäksi suunniteltu siten että tiedostojärjelmän levyformaattia voidaan laajentaa taaksepäin yhteensopivasti.
\texttt{ext2}:lle onkin kehitetty seuraajat \texttt{ext3} ja \texttt{ext4}, joissa olemassa oleva \texttt{ext2}- tai \texttt{ext3}-osio voidaan päivittää seuraavaan
versioon ilman tiedostojärjestelmän uudelleenformatointia~\cite{Ext4Status}.
Merkittävin näiden seuraajien tuoma parannus on \texttt{ext3}:n kirjaus,
joka parantaa huomattavasti tiedostojärjestelmän kykyä säilyä konsistenttina kaatumistilanteessa \texttt{ext2}:n verrattuna.
\texttt{ext3}:a ja kirjaavia tiedostojärjestelmiä yleisesti käsitelläänkin myöhemmin luvussa~\ref{ChapJournallingFs}.

\begin{figure}
    \label{FigExt2DiskFormat}
    \centering
    \includegraphics[width=0.7\textwidth]{gfx/ext2-structure.pdf}
    \caption{\texttt{ext2}:n rakenne levyllä~\cite{LinuxKernelBook}.}
\end{figure}

\texttt{ext2}:n levyrakenne korkealla tasolla on esitetty kuvaajassa~\ref{FigExt2DiskFormat}~\cite{LinuxKernelBook}.
Korkeimmalla tasolla \texttt{ext2}:n rakenne on jaettu kahteen osaan: on \emph{käynnistyslohkoon} sekä useisiin \emph{lohkoryhmiin}.
Käynnistyslohkon tarkoitus on yksinkertaisesti varattua tilaa jollekin \texttt{ext2}:ta riippumattomalle käynnistyslataajalle,
itse tiedostojärjestelmä ei käytä tätä tilaa mitenkään.
Valtaosa \texttt{ext2}:n levynkäytöstä on lohkoryhmiä,
joista jokainen lohkoryhmä viimeistä lukuun ottamatta vie yhtä paljon tilaa levyltä.
Jokainen \texttt{ext2}:n lohkoryhmä on puolestaan jaettu seuraaviin tietorakenteisiin:
\emph{superlohkoon} (superblock),
\emph{lohkoryhmien kuvaajiin} (block group descriptors),
\emph{lohkobittikarttoihin} (block bitmap),
\emph{inodebittikarttoihin} (inode bitmap),
\emph{inodetauluun} (inode table) sekä datalohkoihin.
Näistä superlohko ja lohkoryhmien kuvaajat ovat koko tiedostojärjestelmälle yhtenäistä metadataa,
joiden periaatteessa riittäisi olla levyllä vain kerran,
mutta \texttt{ext2} säilyttää kuitenkin kummastakin niistä useita kopioita siltä varalta että ensisijainen kopio näistä tietorakenteista korruptoituu.

\subsection{Superlohkon sisältö}
Superlohko sisältää muun muassa seuraavanlaisia arvoja tiedostojärjestelmästä, enkoodattuna 32-bittisinä little-endian-kokonaislukuina:
\begin{itemize}
    \item Tiedostojärjestelmän lohkon (block) koko \texttt{s\_log\_block\_size}. Yleisesti käytettyjä lohkon kokoja on 1, 2, ja 4 kilotavua.
          Mahdollisia tiedostojärjestelmän lohkokokoja rajoittaa se, että lohkon koon täytyy olla käytettävän levyn sektorin koon moninkerta.
          %Yleisimmät käytetyt sektorin koot nykypäivänä ovat 512 ja 4096 tavua.
          %Myöskin Linuxin ext2-ajurilla on lisärajoituksena että lohkon koko ei saa ylittää prosessoriarkkitehtuurin sivun kokoa,
          %mikä yleisemmin (muun muassa Intelin x86-arkkitehtuurissa) on 4096 tavua.
    \item Ominaisuusbitit \texttt{s\_\-feature\_\-compat}, \texttt{s\_\-feature\_\-incompat} ja \texttt{s\_feature\_\-ro\_\-compat} jotka kertovat mitä laajennoksia tiedostojärjestelmässä on käytössä.
          Nämä ovat jaettu kolmeen eri luokkaan mikä mahdollistaa sekä taaksepäin- että eteenpäin yhteensopivuuden tietyissä rajoissa.
    \item Lohkoryhmien koot, erikseen datalohkoille ja inodeille.
          \texttt{s\_\-blocks\_\-per\_\-group} kertoo datalohkojen määrän yhdessä lohkoryhmässä ja \texttt{s\_inodes\_\-per\_\-group} inodejen lukumäärän yhdessä lohkoryhmässä.
    \item Vapaiden datalohkojen määrä \texttt{s\_\-free\_\-blocks\_\-count} ja datalohkojen kokonaismäärä \texttt{s\_\-blocks\_\-count}.
    \item Niinikään samat laskurit inodeille: \texttt{s\_free\_\-inodes\_\-count} kertoo vapaiden inodejen määrän ja \texttt{s\_inodes\_count} inodejen kokonaismäärän tiedostojärjestelmässä.
\end{itemize}

\texttt{ext2}:ssa inodeille on varattu tila joka on erillinen datalohkoista.
Tiedostojärjestelmää luodessa valitut \texttt{s\_blocks\_\-per\_\-group}- ja \texttt{s\_inodes\_\-per\_\-group}-parametrit määräävät inodejen ja datalohkojen suhteellisen osuuden koko levytilasta.
\texttt{ext2}:aa käyttäessä voikin joutua tilanteeseen, jossa käyttäjän näkökulmasta levytilaa (eli datalohkoja) on runsaasti vapaana, mutta kaikki inodet ovat käytössä, tai päinvastoin.

\subsection{Lohkoryhmäkuvaajien sisältö}
Kuten superlohkon kohdalla, lohkoryhmäkuvaajista säilytetään kopioita useassa kohtaa levyä.
Lohkoryhmäkuvaajat on yksinkertaisesti taulukko seuraavista tietorakenteesta:
\begin{itemize}
    \item \texttt{bg\_block\_bitmap} kertoo lohkon, josta kyseisen lohkoryhmän lohkobittikartta alkaa.
          Bittikartan bitit kertovat mitkä lohkoryhmän datalohkoista ovat käytössä.
          Ykkösbitti tarkoittaa käytössä olevaa lohkoa ja nollabitti vapaata lohkoa.
    \item \texttt{bg\_inode\_bitmap} kertoo lohkon, josta kyseisen lohkoryhmän inodebittikartta sijaitsee.
          Inodebittikartta kertoo mitkä kyseisen lohkoryhmän inodeista on käytössä.
          Samaan tapaan kuin lohkobittikartan kanssa, 1 tarkoittaa käytössä olevaa inodea ja 0 vapaata inodea.
    \item \texttt{bg\_free\_blocks\_count} ja \texttt{bg\_free\_inodes\_count} kertovat vapaiden lohkojen ja inodejen lukumäärän kyseisessä lohkoryhmässä.
          % Koska nämä kentät ovat vain 16-bittisiä, yhden lohkoryhmän
    \item \texttt{bg\_inode\_table} kertoo mistä lohkosta kyseisen lohkoryhmän inodetaulu alkaa. Lohkoryhmän datalohkot sijaitsevat heti lohkoryhmän inodetaulun jälkeen.
\end{itemize}

\subsection{Inoden rakenne}

\texttt{ext2}:ssa tietyn inoden paikannus inodenumeron perusteella on yksinkertaista.
Kuten edellä nähtiin, jokaisessa lohkoryhmässä on sama määrä inodeja ja lohkoryhmän sisällä inodet sijaitsevat yksinkertaisesti taulukossa.
Inodeiden numerointi alkaa ykkösestä, joten inoden numerosta voidaan laskea lohkoryhmän numero kaavalla:
$$ n_\text{bg} = \frac{n_\text{ino} - 1}{\texttt{s\_inodes\_per\_group}} $$

Kenttä \texttt{i\_blocks} viittaa lohkoihin jossa inoden data sijaitsee.
Kentän formaatti on 15-alkioinen taulukko 32-bittisiä kokonaislukuja jonka sisältö tulkitaan seuraavasti:
\begin{itemize}
    \item Taulukon ensimmäiset 12 alkiota sisältävät lohkonumerot tiedoston ensimmäiselle 12 lohkolle (lohkot 0--11).
          Nämä ovat \emph{suoria lohkoja} (\emph{direct blocks}).
    \item Taulukon seuraava (13.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{epäsuoraan lohkoon} (\emph{indirect block}).
          Itse epäsuora lohko taas sisältää taulukon lohkonumeroita, jotka kertovat inoden seuraavat datalohkojen numerot.
          Esimerkiksi jos tiedostojärjestelmän lohkokoko on 4096, sisältää epäsuora lohko 1024 lohkonumeroa,
          jolloin lohkot 12 -- 1035 löytyvät ensimmäisen epäsuoran lohkon kautta.
    \item Taulukon seuraava (14.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{toisen tason epäsuoraan lohkoon} (\emph{doubly indirect block}).
    \item Taulukon seuraava (15.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{kolmannen tason epäsuoraan lohkoon} (\emph{triply indirect block}).
\end{itemize}

\begin{figure}
    \label{FigExt2BlockMap}
    \centering
    \includegraphics[scale=1.1]{gfx/ext2-blocks.pdf}
    \caption{Ext2:n lohkopuu.}
\end{figure}

\subsection{Hakemiston rakenne}
\texttt{ext2}:n hakemisto koostuu \emph{hakemistoalkioista} (directory entry) jotka sijaitsevat inoden datalohkoissa.
Hakemistoalkion koko on vaihtelevanmittainen riippuen hakemistoalkion sisältämän tiedostonimen pituudesta.
Hakemistoalkio sijaitsee aina kokonaan yhden datalohkon sisällä.
Hakemistoalkio koostuu vakiokokoisesta otsakkeesta jota välittömästi seuraa tiedostonimi.
Otsakkeen rakenne on seuraavanlainen:

\begin{samepage}
\begin{minted}{c}
	uint32_t inode;
	uint16_t rec_len;
	uint8_t name_len;
	uint8_t file_type;
\end{minted}
\end{samepage}
%
Kenttä \texttt{inode} sisältää hakemistoalkion viittaavan inoden numeron,
jossa inodenumero 0 tarkoittaa käyttämätöntä tilaa hakemistossa.
Otsakkeen kenttä \texttt{name\_len} kertoo tiedostonimen pituuden.
Koska kentän koko on 8 bittiä, rajoittuu tiedostonimen maksimipituudeksi 255.
Kenttä \texttt{rec\_len} kertoo koko hakemistoalkion koon,
jonka perusteella voidaan paikantaa hakemiston seuraava hakemistoalkio.
joka voi olla suurempi kuin otsakkeen koko ja tiedostonimen pituus.

\texttt{ext2}:ssa siis hakemistoalkion paikantaminen tiedostonimen perusteella on aikavaativuudeltaan $O(n)$,
mikä tarkoittaa heikkoa suorituskykyä hakemiston koon kasvaessa.
Yksi \texttt{ext2}:n välittömän seuraajan, \texttt{ext3}:n tuomista uudistuksista on hajautukseen pohjautuva hakemistorakenne.

\subsection{Esimerkki hakemistosta}
Tarkastellaan hakemiston rakennetta luotaessa 1024 tavun lohkokokoa käyttävän tiedostojärjestelmän juureen alihakemisto \texttt{dir} ja sinne tyhjät tiedostot \texttt{abc}, \texttt{defghijklmn} ja \texttt{opqrstuvwxyz}.
Linux-ajurin luoma rakenne on seuraavanlainen:

\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    12 & 12  & 1  & \texttt{"."}            sekä 3 0-tavua. \\
    2  & 12  & 2  & \texttt{".."}           sekä 2 0-tavua. \\
    13 & 12  & 3  & \texttt{"abc"}          sekä 1 0-tavu. \\
    14 & 20  & 11 & \texttt{"defghijklmn"}  sekä 1 0-tavu. \\
    15 & 968 & 12 & \texttt{"opqrstuvwxyz"} sekä loput alkiosta ovat 0-tavuja. \\
\end{tabular}
%
Nyt poistettaessa tiedosto \texttt{defghijklmn} muuttuu kolmannen hakemistoalkion (nimen \texttt{abc}) sisällöksi:

\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    13 & 20  & 3  & "abc"\\
\end{tabular}
%
Siis poistettavaa hakemistoalkiota edeltävän hakemistoalkion \texttt{rec\_len}-kenttää kasvatetaan ``hyppäämään'' poistetun alkion yli.

\section{\texttt{ext2} kaatumistilanteissa}
\label{ChapExt2Crash}
Keskitytään seuraavaksi kaatumistilanteisiin ja niistä syntyviin mahdollisiin epäkonsistenssiuksiin \texttt{ext2}:n levytietorakenteisiin.
Tarkastellaan ensin tiedostojärjestelmän konsistenssiuden määritteleviä invariantteja sekä miten niitä tarkistetaan ja korjataan \texttt{fsck}-työkalulla.
Lisäksi tutkitaan käytännössä miten Linuxin \texttt{ext2}-tiedostojärjestelmäajuri tekee levykirjoituksia ja mitä käytännön seurauksia kaatumistilanteilla on.

\subsection{Tiedostojärjestelmän invariantit ja tarkistus- ja korjausohjelma \emph{fsck}}

Kuten edellisen luvun kuvauksesta \texttt{ext2}:n levytietorakenteista selvisi,
yksinkertainenkin tiedostojärjestelmä koostuu useasta eri levylle kirjoitettavasta tietorakenteesta.
Monet näistä levytietorakenteista ovat selkästi toisistaan riippuvia.
Esimerkiksi \texttt{ext2}:ssa vapaiden lohkojen määrää ylläpidetään sekä superlohkossa, jokaisessa lohkoryhmäkuvaajassa että lohkobittikartassa.
Konsistentissa tiedostojärjestelmässä täytyy siis esimerkiksi päteä seuraavat invariantit: lohkobittikartassa vapaaksi merkittyjä lohkoja on sama määrä kuin mitä superlohkon vapaiden lohkojen laskuri näyttää,
jonka täytyy olla edelleen sama määrä kuin mitä jokaisen lohkoryhmän vapaiden lohkojen laskurin summa on.
Koska jokainen näistä tietorakenteista sijaitsee levyn eri sektorilla ja saattaa olla usean sektorin kokoinen,
ei kaikkia tietorakenteita ole mahdollista päivittää atomisesti.
Eri sektoreiden kirjoitusten välissä tapahtuva kaatumistilanne voi siis johtaa tilanteeseen jossa vain osa kirjoituksista on päätynyt levylle asti
ja tiedostojärjestelmä ei ole enää konsistentissa tilassa.

Tiedostojärjestelmien konsistenssiuden tarkastamiseen ja korjaamiseen käytetään perinteisesti \texttt{fsck} (\emph{file system check})-nimistä työkalua.
Koska jokaisella tiedostojärjestelmällä on oma levyformaattinsa,
on jokaiselle tiedostojärjestelmälle oma \texttt{fsck}-työkalu,
joka \texttt{ext2}:n tapauksessa on \texttt{e2fsck}.
Kaatumistilanteiden lisäksi \texttt{fsck}-työkalun tulee kyetä tunnistamaan ja korjaamaan parhaansa mukaan muitakin mahdollisia korruptioita,
kuten esimerkiksi laitteistosta tai tiedostojärjestelmäajurin ohjelmointivirheistä aiheutuneita virheitä.
Tämä tekee prosessista varsin monimutkaisen ja edellyttää koko tiedostojärjestelmän metadatan läpikäyntiä,
mikä voi suurella tiedostojärjestelmällä kestää pitkään.
\texttt{e2fsck}:n tapauksessa mahdollisia tiedostojärjestelmään tehtäviä korjauksia on yli 120 ja ne tehdään kuudessa eri vaiheessa~\cite{SQCK}.
Vaiheet ja merkittävimmät niissä tehtävät tarkistukset ja korjaukset ovat:
%
\begin{enumerate}
      \item{Superlohkon ja lohkoryhmän tarkistus.}
      \item{Inodejen ja lohko-osoittimien tarkistus:
            kuhunkin data- tai epäsuoraan lohkoon saa olla korkeintaan yksi viittaus.}
        \item{Hakemistojen tarkistus: jokainen hakemistoalkio osoittaa käytössä olevaan inodeen, hakemistoinodeen saa olla korkeintaan yksi viittaava hakemistoalkio,}
      \item{Hakemistopuun yhtenäisyyden tarkistus: kaikkiin käytössä oleviin inodeihin pitää pystyä kulkemaan juurihakemistosta lähtien.}
      \item{Inodeen viittaavien hakemistoalkioiden määrän laskurit päivitetään vastaamaan todellista määrää.}
      \item{Lohko- ja inodebittikartat sekä vapaiden lohkojen ja inodejen laskurit päivitetään vastaavaan todellista tilannetta.}
\end{enumerate}
%

\subsection{Kaatumistilanteiden tutkiminen käytännössä}
\texttt{ext2}-tiedostojärjestelmän käyttäytymistä kaatumistilanteessa testattiin käytännössä QEMU-virtuaalikoneen \texttt{blk\-log\-writes}-lohkolaitteen avulla.
\texttt{blk\-log\-writes} on virtuaalinen lohkolaite joka näkyy käyttöjärjestelmälle muuten tavallisena levynä,
mutta jokaisen kirjoitusoperaation yhteydessä tehdään lisäksi lokimerkintä joka sisältää aikaleiman, kirjoitettavan sektorin numeron sekä lohkon uuden sisällön.
Koeasetelmassa virtuaalikoneessa käynnistetään Linux,
liitetään tiedostojärjestelmä \texttt{blklogwrites}:in päälle ja tehdään sille haluttuja tiedostojärjestelmäoperaatioita,
ja sammutetaan virtuaalikone.
Nyt levykirjoituslokin pohjalta voidaan jälkikäteen muodostaa jokainen mahdollinen välitilanne levyn sisällöstä,
jossa jokainen välitilanne vastaa yhtä mahdollista kaatumistilannetta testitilanteen aikana.

Koeasetelmassa käytettiin Linuxin versiota 4.14, QEMUn versiota 3.0.0 ja 1 gigatavun levyä.
Lisäksi tiedostojärjestelmäoperaatioita ei tehdä peräjälkeen tai heti liittämisen jälkeen,
vaan niiden välissä odotetaan 3 minuuttia.
Tällä lailla voidaan erottaa levykirjoitukset,
jotka tapahtuvat suoraan tiedostojärjestelmäoperaation seurauksena
ja mitkä käyttöjärjestelmä kirjoittaa taustalla. 

\subsubsection{Tiedoston luominen}
\label{ChapExt2FileCreation}
Taulukossa~\ref{TabExt2Creation} nähdään levykirjoitukset,
jota aiheutuu luotaessa tyhjään \texttt{ext2}-tiedostojärjestelmän juurihakemistoon uusi tyhjä tiedosto kutsulla \texttt{creat("new", 0755)}:

% Before:
% debugfs 1.44.1 (24-Mar-2018)
% debugfs:  stat /
% Inode: 2   Type: directory    Mode:  0755   Flags: 0x0
% Generation: 0    Version: 0x00000000:00000000
% User:     0   Group:     0   Project:     0   Size: 4096
% File ACL: 0
% Links: 3   Blockcount: 8
% Fragment:  Address: 0    Number: 0    Size: 0
%  ctime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018 *** changed
%  atime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018
%  mtime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018 *** changed
% crtime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018
% Size of extra inode fields: 32
% BLOCKS:
% (0):516
% TOTAL: 1


% After:
% debugfs:  stat /
% Inode: 2   Type: directory    Mode:  0755   Flags: 0x0
% Generation: 0    Version: 0x00000000:00000001
% User:     0   Group:     0   Project:     0   Size: 4096
% File ACL: 0
% Links: 3   Blockcount: 8
% Fragment:  Address: 0    Number: 0    Size: 0
%  ctime: 0x5baa3ca6:c24fa700 -- Tue Sep 25 16:48:22 2018
%  atime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018
%  mtime: 0x5baa3ca6:c24fa700 -- Tue Sep 25 16:48:22 2018
% crtime: 0x5ba8fc96:00000000 -- Mon Sep 24 18:02:46 2018
% Size of extra inode fields: 32
% BLOCKS:
% (0):516
% TOTAL: 1
%
% debugfs:  stat <12>
% Inode: 12   Type: regular    Mode:  0644   Flags: 0x0
% Generation: 1493743292    Version: 0x00000000:00000001
% User:     0   Group:     0   Project:     0   Size: 65536
% File ACL: 0
% Links: 1   Blockcount: 136
% Fragment:  Address: 0    Number: 0    Size: 0
%  ctime: 0x5baa3ca6:c24fa700 -- Tue Sep 25 16:48:22 2018
%  atime: 0x5baa3ca6:c2129e00 -- Tue Sep 25 16:48:22 2018
%  mtime: 0x5baa3ca6:c24fa700 -- Tue Sep 25 16:48:22 2018
% crtime: 0x5baa3ca6:c2129e00 -- Tue Sep 25 16:48:22 2018
% Size of extra inode fields: 32
% BLOCKS:
% (0-11):9216-9227, (IND):8722, (12-15):9228-9231
% TOTAL: 17
% => type, mode, size, blkcount, timestamps, block pointers

\begin{table}[H]
\label{TabExt2Creation}
\begin{tabular}{l | l | l | l | p{7cm}}
    \# & $t$ (s) & $\Delta t$ (s) & lohkot & kuvaus \\ \hline \hline
    1  & 0.000    &          &     & \texttt{creat()}-kutsu alkaa   \\ \hline %
    2  & 0.001    & +0.001   &     & \texttt{creat()}-kutsu loppuu  \\ \hline %
    3  & 30.847   & +30.846  & 1   & Lohkoryhmien kuvaajat: vähennetään vapaiden inodejen määrää (8181 -> 8180)         \\ \hline % 3
    4  & 30.847   & +0.000   & 3   & Lohkoryhmän 0 inodebittikartta: merkitään inode 12 varatuksi \\ \hline % 2
    5  & 30.847   & +0.000   & 516 & Juurihakemisto: lisätään hakemistoalkio \texttt{new} osoittamaan inodeen 12                 \\ \hline % 1
    6  & 61.567   & +30.721  & 4   & Lohkoryhmän 0 inodetaulu: inoden 12 käyttöoikeudet, aikaleimat, koko sekä lohkoviittaukset alustetaan. Juurihakemistoinoden aikaleimoja päivitetään. \\        % 4
\end{tabular}
\caption{Tiedoston luomisesta seuraavat levyoperaatiot.}
\end{table}
%
Esimerkistä ilmenee selvästi miten \texttt{ext2} hyödyntää välimuistia levyn metadatarakenteille: \texttt{creat()}-kutsu palaa välittömästi eikä siitä aiheudu välittömiä levykirjoituksia.
Vasta 30 sekuntia myöhemmin tehdään ensimmäiset kolme kirjoitusta,
jota seuraa toinen 30 sekunnin odotus ennen kuin koko operaatio on saatettu loppuun levyllä.
Kokonaisuudessaan esimerkki näyttää miten tiedoston luominen on varsin yksinkertaista.
Levyltä varataan yksi vapaa inode (tässä esimerkissä 12), alustetaan se ja lisätään hakemistoalkio osoittamaan siihen.
%
Tämän esimerkin kaatumistilanne voi aiheuttaa seuraavia epäkonsistenssiuksia:
\begin{enumerate}
    \item{Kohtien 3--4 välissä: vapaiden inodejen laskuri näyttää vapaita inodeja olevan vähemmän kuin niitä todellisuudessa on.}
    \item{Kohtien 4--5 välissä: inodebittikartta näyttää vapaita inodeja olevan vähemmän kuin niitä todellisuudessa on.}
    \item{Kohtien 5--6 välissä: juurihakemiston hakemistoalkio \texttt{new} osoittaa nyt inodetaulussa alustamattomaan inodeen.}
\end{enumerate}
%
Näistä kaksi ensimmäistä johtaa inodejen `vuotamiseen',
eli tiedostojärjestelmässä näyttää olevan vähemmän vapaita inodeja saatavilla kuin siellä todellisuudessa on.
Tämä ei sinänsä ole suoraan este tiedostojärjestelmän käytölle,
mutta \texttt{fsck}-ohjelma täytyy ajaa jotta resurssit saadaan takaisin käyttöön.
Kolmannessa tapauksessa seuraukset ovat merkittävästi ikävämpiä.
Hakemistoalkio \texttt{new} näkyy hakemistolistauksessa mutta kaikki siihen vaikuttavat tiedostojärjestelmäoperaatiot epäonnistuvat virheellä ``Input/output error''.
Käyttäjän näkökulmasta tiedostojärjestelmään on siis syntynyt `viallinen' tiedosto jolle ei voi tehdä mitään, edes poistaa.

%%%%% Levyn liittämisen yhteydessä tehdään yksi levykirjoitus superlohkoon, jossa asetetaan lippu että tiedostojärjestelmä on käytössä.
%%%%% %  Filesystem state: clean -> not clean, Mount count: 1 -> 2, Last mount time: *
%%%%% Tämä kertoo että kaatumistilanteessa tiedostojärjestelmän tila on epäkonsistentti ja on tarpeen ajaa e2fsck ennen tiedostojärjestelmän liittämistä.
%%%%% Linuxin tapa käyttää levyvälimuisteja aggressiivisesti näkyy jo näinkin yksinkertaisella testitapauksella,
%%%%% sillä itse \texttt{creat()}-kutsu ei tee mitään levykirjoituksia vaan palaa heti sovellusohjelmalle.
%%%%% Vasta noin 30 sekunnin jälkeen aletaan tehdä muutoksia levylle.
%%%%% Kohdassa 6 päivitään lohkoryhmän vapaiden inodejen määrää yhdellä (8181 -> 8180), kohdassa 7 merkitään uudelle tiedostolle varattu inode käytössä olevaksi inodebittikarttaan
%%%%% ja kohdassa 8 lisätään juurihakemistoon hakemistoalkio viittaamaan uuden tiedoston inodeen.
%%%%% Edelleen 30 sekuntia myöhemmin muokataan inodetaulua, missä samalla alustetaan uuden inoden sisältö sekä päivitetään juurihakemiston aikaleimoja.
%%%%% 
%%%%% Nähtävästi superlohkon metadata kirjoitetaan vasta unmountin yhteydessä, käyttäen kolmea kirjoitusta peräkkäin.
%%%%% Kohdassa 11 vähennetään tiedostojärjestelmän vapaiden inodejen määrää (65525 -> 65524).
%%%%% % Last write time:*
%%%%% Kohdan 12 levykirjoituksen tarkoitus on tuntematon, sillä se ei muuta levyn sisältöä mitenkään.
%%%%% Kohta 13 päivittää tiedostojärjestelmän tilan puhtaaksi.

\subsubsection{Tiedostoon kirjoitus}
\label{ChapExt2FileWrite}
Jatketaan edellisen kohdan tiedostojärjestelmästä ja kirjoitetaan \texttt{new}-tiedostoon 64 kilotavun eli 16 lohkon verran dataa:
% \texttt{creat("new", 0755)} tapahtuu seuraavasti:
\begin{table}[H]
\begin{tabular}{l | l | l | l | p{7cm}}
    \# & $t$ (s) & $\Delta t$ (s) & lohkot & kuvaus \\ \hline \hline
    1  & 0.000    & +0.000   &            & \texttt{open()}-kutsu alkaa    \\ \hline %
    2  & 0.028    & +0.028   &            & \texttt{open()}-kutsu loppuu   \\ \hline %
    3  & 0.028    & +0.000   &            & \texttt{write()}-kutsu alkaa   \\ \hline %
    4  & 0.028    & +0.000   &            & \texttt{write()}-kutsu loppuu  \\ \hline %
    5  & 5.226    & +5.198   & 1          & Lohkoryhmien kuvaajat: vapaiden lohkojen määrää vähennetään (32247 -> 32230)                             \\ \hline % 1
    6  & 5.226    & +0.000   & 2          & Lohkoryhmän 0 lohkobittikartta: varataan lohkot 8192 -- 8208         \\ \hline % 2
    7  & 5.226    & +0.000   & 4          & Lohkoryhmän 0 inodetaulu: inoden \texttt{new} attribuuteista päivitetään sen koko, aikaleima ja viittaukset data- ja epäsuoriin lohkoihin               \\ \hline % 2
    8  & 5.226    & +0.000   & 8192 -- 8208 & Tiedoston \texttt{new} 16 datalohkoa sekä yksi epäsuora lohko                            \\        % 3
\end{tabular}
\caption{Olemassa olevan tiedostoon lisäyksestä seuraavat levyoperaatiot.}
\end{table}

Levyvälimuistien olemassaolo näkyy tässäkin esimerkissä,
sillä \texttt{write()}-operaatio ei aiheuta levykirjoituksia vaan ne tehdään taustalla vasta viiden sekunnin päästä.
%
Tämän esimerkin kaatumistilanne voi puolestaan aiheuttaa seuraavia epäkonsistenssiuksia:
\begin{enumerate}
    \item{Kohtien 5--6 välissä: vapaiden lohkojen laskuri näyttää vapaita lohkoja olevan vähemmän kuin niitä todellisuudessa on.}
    \item{Kohtien 6--7 välissä: lohkobittikartta näyttää vapaita lohkoja olevan vähemmän kuin niitä todellisuudessa on.}
    \item{Kohtien 7--8 välissä: tiedostoa \texttt{new} vastaava inode viittaa alustamattomiin lohkoihin.}
\end{enumerate}
%
Näistä tilanteista kaksi ensimmäistä johtaa datalohkojen vuotamiseen,
eli samantyyppiseen tilanteeseen kuten edellisen aliluvun esimerkissä josta aiheutui vapaiden inodejen vuotaminen.
Kolmannessa kaatumistilanteessa taas päädytään tilanteeseen,
missä tiedoston \texttt{new} inoden kokoa on kasvatettu onnistuneesti ja siihen on lisätty viittaukset datalohkoihin sekä epäsuoraan lohkoon,
mutta itse lohkojen sisältö jäi kirjoittamatta.
Datalohkojen osalta tämä tietää mahdollista tietoturvaongelmaa,
sillä alustamattomat datalohkot ovat voineet olla osa jotakin jonkun toisen käyttäjän omistamaa sittemmin poistettua tiedostoa.
Nyt ne ovat kaatumistilanteen seurauksena luettavissa \texttt{new}-tiedostosta,
eikä \texttt{e2fsck} kykene tunnistamaan tai korjaamaan tilannetta ollenkaan.

Alustamattoman epäsuoran lohkon seuraukset ovat sitäkin vakavammat,
koska lohkon aiempi data tulkitaan nyt lohko-osoittimina.
Pahimmillaan alustamaton lohko-osoitin voi osoittaa jonkun muun inoden omistamaan lohkoon,
jolloin \texttt{new}-tiedoston olemassa olevan sisällön ylikirjoittaminen vaikuttaisi johonkin muuhun tiedostojärjestelmän inodeen.
Tiedostojärjestelmän käyttö tässä tilanteessa ei siis ole turvallista ennen tiedostojärjestelmän korjausta \texttt{e2fsck}-työkalulla.

% 7  & 5.226    & +0.000   & 4          & Lohkoryhmän 0 inodetaulu: inoden \texttt{new} attribuuteista päivitetään sen koko, varattujen lohkojen määrä, aikaleima, suorat lohkoviittaukset, epäsuora lohkoviite.               \\ \hline % 2
% 8  & 5.226    & +0.000   & 8192 -- 8208 & Tiedoston \texttt{new} 16 data kirjoitetaan lohkoille 8192 -- 8203 ja 8205 -- 8208 sekä yksi epäsuora lohko lohkolle 8204.                           \\        % 3

\section{Kirjaavat tiedostojärjestelmät}
\label{ChapJournallingFs}
Edellisessä luvuissa nähtiin mitä seurauksia kaatumistilanteilla on \texttt{ext2}-tiedostojärjestelmälle,
joiden johdosta koko tiedostojärjestelmän metadata täytyy käydä läpi \texttt{e2fsck}-ohjelmalla konsistenssin palauttamiseksi.
Tarkastellaan seuraavaksi miten \texttt{ext2}:n seuraaja \texttt{ext3} käyttää \emph{kirjausta} (\emph{journalling}) varmistamaan että tiedostojärjestelmä säilyy konsistenssina kaatumistilanteiden aikanakin.

\subsection{Motivaatio \texttt{ext3}:lle}
Tarve \texttt{ext2}:n jatkokehitykselle syntyi pääosin kaatumistilanteista selviämiseen,
sillä kiintolevyjen koon kasvaessa kasvoi myös \texttt{fsck}-ohjelman viemä aika samaa tahtia~\cite{Ext2Journal}.
Tavoitteeksi asetettiin luoda menetelmä kaatumistilanteista selviämiseen joka ei vaadi pitkää palautumisaikaa jolloin tiedostojärjestelmä ei ole käytettävissä.
Nopeuden lisäksi samalla tavoiteltiin parannuksia tiedostojärjestelmän kaatumisesta palautumiseen seuraavilla kriteereillä~\cite{Ext2Journal}:
\begin{itemize}
    \item{Säilyvyys: kaatumistilanteesta palautuminen ei saa vaikuttaa dataan tai metadataan joka on onnistuneesti kertaalleen päätynyt levylle asti ennen kaatumistilannetta.}
    \item{Ennakoitavuus: kaatumistilanteesta palautuessa tehtävät vaiheet täytyy olla ennakoitavissa.}
    \item{Atomisuus: sovellusohjelmoijan näkökulmasta atomiset operaatiot, kuten esimerkiksi tiedoston uudelleennimeäminen \texttt{rename()}-kutsulla säilyvät atomisena kaatumistilanteissakin.}
\end{itemize}
Näistä kriteereistä \texttt{ext2} täyttää ainoastaan säilyvyyden.
Levyvälimuistien takia kaatumistilanteen aikana meneillään on voinut olla useaan POSIX-tiedostojärjestelmäoperaation liittyviä levytietorakenteiden päivityksiä,
joten \texttt{e2fsck}:n täytyy varautua tekemään merkittävä määrä erityyppisiä korjauksia.
Atomisuuden osalta \texttt{ext2} rajoittuu vain siihen mitä levyjärjestelmä pystyy,
eli hakemistoalkion uudelleennimeäminen toisella levysektorilla sijaitsevaan hakemistolohkon sektoriin ei ole atomisesti mahdollista.
%Koska kaatumistilanteen aiheuttamien seuraamuksien todettiin olevan varsin ikäviä,
%ovat monet \texttt{ext2}:ta edistyneemmät tiedostojärjestelmät kehittäneet menetelmiä kaatumistilanteita varten.
%Eräs varsin laajasti käytetty tekniikka on \emph{kirjaavat}tai \emph{journaloivat} tiedostojärjestelmät (\emph{journalling file system}).
%Tätä tekniikkaa käyttääkin \texttt{ext2}:n seuraaja \texttt{ext3}, sekä sen lisäksi
%muun muassa IBM:n JFS sekä Microsoftin NTFS~\cite{JournalingAnalysis}.
%Kirjauksen toteuttaminen tiedostojärjestelmään voidaan tehdä muutamalla eri lähestymistavalla.
%Tässä luvussa kuitenkin tarkastellaan pääosin \texttt{ext3}:n toteutusta kirjauksesta.
%

Yksi keino kaikkien näiden kriteereiden täyttämiseksi on lisätä tiedostojärjestelmään jokin menetelmä \emph{transaktioille},
joilla koko tiedostojärjestelmän metadataan voidaan tehdä päivityksiä atomisesti.
\texttt{ext3} toteuttaa transaktioille käyttäen kirjausta,
joka pohjautuu pääpiirteissään tietokantajärjestelmissä käytettyyn Write-Ahead Logging-menetelmään~\cite{AriesWal}.
Kirjauksen perusajatuksena on että aina ennen varsinaisten levytietorakenteiden muuttamista kirjataan ylös erilliseen \emph{journaliin} ylös kaikki muutokset,
jota transaktion yhteydessä tullaan tekemään.
Nyt mahdollisen kaatumistilanteen sattuessa voidaan journalin sisällön perusteella aina toistaa kaikki muutokset ja viedä transaktio loppuun.

%\subsection{Kirjauksen toimintaperiaate}
%
%Ennen metadatalohkojen kirjoitusta niiden varsinaisille paikalleen levyllä, kopio niistä kirjataan lokiin.
%Kirjauksen vaatima loki on kiinteän pituinen ja tila sille on varattu piilotetun, tiedostojärjestelmän käyttäjällä näkymättömän inoden avulla.

\subsection{Kirjauksen toteutus \texttt{ext3}:ssa}
Aiemmin luvussa~\ref{ChapExt2Fs} nähtiin miten \texttt{ext2}:n levyformaattia voidaan laajentaa tulevaisuudessa ominaisuusbiteillä.
Vaikka useassa yhteydessä \texttt{ext3}:sta puhutaan ikään kuin se olisi oma erillinen tiedostojärjestelmänsä,
on se levyformaatin näkökulmasta edelleen \texttt{ext2}-tiedostojärjestelmä mutta varustettuna lisäominaisuuksilla.
Relevantteja ominaisuusbittejä ovat `taaksepäin yhteensopivat' ominaisuudet \texttt{has\_journal} ja \texttt{dir\_index} sekä `ei-taaksepäin yhteensopiva` ominaisuus \texttt{needs\_recovery}.
Ominaisuus \texttt{dir\_index} tuo hakemistoihin hajautukseen pohjautuvan indeksirakenteen nopeuttamaan hakemistosta hakua tiedostonimen perusteella ja voidaan sivuuttaa kaatumisturvallisuuden tutkimisen kannalta.

%Ominaisuus \texttt{journal} tarkoittaa että journalille on varattu tila levyltä kun taas \texttt{needs\_recovery} asetetaan ilmaisemaan että journalin läpikäynti tarvitaan konsistenssin palautumiseen.
Toisin kuin monille muille \texttt{ext2}:n levytietorakenteille, journalin sijaintia levyllä ei ole ennalta määrätty vaan tila sille varataan erityisen inoden avulla data-alueelta samaan tapaan kuin muille tiedostoille~\cite{Ext2Journal}.
Muista inodeista poiketen journalin inode ei ole paikannettavissa normaalisti hakemistorakenteen kautta vaan se paikannetaan \texttt{journal}-laajennoksen tuomasta uudesta superlohkon kentästä.
Inoden käyttö journalin lohkojen paikantamiseen mahdollistaa journalin lisäämisen olemassa olevaan \texttt{ext2}-tiedostojärjestelmään helposti kunhan tiedostojärjestelmässä on vapaata tilaa.
ilman että koko tiedostojärjestelmää täytyy alustaa uudelleen.

Itse journalin levyformaatti alkaa \emph{otsakelohkolla} (\emph{header block}) joka kertoo journalin alkukohdan,
eli mistä lohkosta eteenpäin journalia aletaan lukemaan kaatumistilanteesta palautuessa~\cite{JournalingAnalysis}.
Journaliin kirjoitettu kokonainen transaktio koostuu \emph{kuvaajalohkosta} (\emph{journal descriptor block}),
jota seuraa joukko metadatalohkoja,
ja jonka päättää \emph{sitoutumislohko} (\emph{journal commit block}).
Kuvaajalohko aloittaa transaktion kertomalla mitä lohkoja transaktion aikana tullaan muokkaamaan,
eli muokattavien lohkojen lukumäärä $n$ ja lista lohkonumeroita.
Kuvaajalohkoa seuraa kunkin muokattavan lohkon sisältö, eli yhteensä $n$ sisältölohkoa.
Transaktion päättää sitoutumislohko,
jonka olemassaololla voidaan tunnistaa journaliin keskeneräisesti kirjoitetut transaktiot.

Kaatumisesta palautuminen tämän pohjalta on varsin yksinkertaista.
Journalia aletaan lukea otsakelohkon ilmaisemasta kohdasta eteenpäin,
ja jokaisen kokonaan lokiin kirjoitetun transaktion sisältölohkot kirjoitetaan kuvaajalohkon osoittamiin paikkoihin levyllä.

\subsection{Käytännön esimerkki \texttt{ext3}:n tekemistä levykirjoituksista}
\texttt{ext3}:n tekemiä levykirjoituksia tutkittiin QEMU-virtuaalikoneella samanlaisella testiasetelmalla kuin aiemmin \texttt{ext2}:n kohdalla tehtiin luvussa~\ref{ChapExt2Fs}.
1 gigatavun levylle \texttt{mkfs.ext3} loi rakenteeltaan muuten samanlaisen tiedostojärjestelmän kuin \texttt{ext2}:n tapauksessa,
paitsi että lohkoryhmä 0 sisältää 32 megatavun kokoisen journalin.
Testiohjelmana käytetään seuraavaa koodinpätkää,
joka luo tiedostojärjestelmään uuden tiedoston \texttt{new} ja kirjoittaa sinne 64 kilotavua dataa:
%
\begin{minted}{c}
    int fd = creat("/mnt/fs/new", 0644);
    write(fd, "XXX...XXX", 64 * 1024);
    close(fd);
\end{minted}
%
Molemmat testiohjelman tekemät tiedostojärjestelmäkutsut valmistuvat aiheuttamatta yhtään levykirjoituksia,
eli \texttt{ext2}:n tapaan operaation tehdään ensin pelkästään muistissa ja kirjoitetaan vasta myöhemmin taustalla levylle:

\begin{table}[H]
\label{TabExt3CreatAndWrite}
\begin{tabular}{l | l | l | l | l | p{7cm}}
    \# & aika (s) & $\Delta t$ & lohko & lkm & kuvaus \\ \hline \hline
    1  & 0.000    & +0.000   &      &      & \texttt{creat()}-kutsu alkaa   \\ \hline %
    2  & 0.001    & +0.001   &      &      & \texttt{creat()}-kutsu loppuu  \\ \hline %
    3  & 0.002    & +0.000   &      &      & \texttt{write()}-kutsu alkaa   \\ \hline %
    4  & 0.002    & +0.001   &      &      & \texttt{write()}-kutsu loppuu  \\ \hline %
    5  & 5.411    & +5.408   & 521  & 1    & Journalin otsakelohko: palautuminen on tarpeen alkaen journalin lohkosta 1                       \\ \hline % 3
    6  & 5.411    & +0.000   & 9216 & 16   & Tiedoston \texttt{new} datalohkot                               \\ \hline % 2
    7  & 5.411    & +0.000   & 522  & 8    & Journalin lohkoihin 1--8 kirjoitetaan yksi kuvaajalohko sekä 7 sisältölohkoa. Päivitettävät lohkot ovat 3, 1, 4, 516, 0, 2, 8722                       \\ \hline % 4
    8  & 5.411    & +0.000   & 530  & 1    & Journalin lohko 9: sitoutumislohko                       \\ \hline % 6
    9  & 36.131   & +30.720  & 0    & 1    & Superlohko: vapaiden lohkojen ja inodejen määriä vähennetään                     \\ \hline % 10
    10 & 36.131   & +0.000   & 1    & 1    & Lohkoryhmien kuvaajat: vapaiden lohkojen ja inodejen määriä vähennetään                     \\ \hline % 10
    11 & 36.131   & +0.000   & 2    & 1    & Lohkobittikartta: merkitään lohkot 8722 ja 9216--9231 varatuksi                     \\ \hline % 10
    12 & 36.131   & +0.000   & 3    & 1    & Lohkoryhmän 0 inodebittikartta: merkitään inode 12 varatuksi \\ \hline % 10
    13 & 36.131   & +0.000   & 4    & 1    & Lohkoryhmän 0 inodetaulu: inoden 12 käyttöoikeudet, aikaleimat, koko sekä lohkoviittaukset alustetaan. Juurihakemistoinoden aikaleimoja päivitetään.                      \\ \hline % 10
    14 & 36.131   & +0.000   & 516  & 1    & Juurihakemisto: lisätään hakemistoalkio \texttt{new} osoittamaan inodeen 12                 \\ \hline % 9
    15 & 36.131   & +0.000   & 8722 & 1    & Tiedoston \texttt{new} epäsuora lohko: tiedoston lohkot 12--15 merkitään viittaamaan lohkoihin 9228--9231 \\        % 8
\end{tabular}
\caption{Tiedoston luonnista ja sinne kirjoittamisesta seuraavat levyoperaatiot \texttt{ext3}-tiedostojärjestelmässä.}
\end{table}

%%%%% \begin{enumerate}
%%%%%     \item{Noin 5.4 sekunnin jälkeen journalin lohkoon 0 eli otsakelohkoon päivitetään kertomaan että palautuminen on tarpeen alkaen journalin lohkosta 1.}
%%%%%     \item{64 kilotavun edestä datalohkot kirjoitetaan data-alueelle.}
%%%%%     \item{Journalin lohkoihin 1--8 kirjoitetaan yksi kuvaajalohko sekä 7 sisältölohkoa. Päivitettävät lohkot ovat 3, 1, 4, 516, 0, 2, 8722.}
%%%%%     \item{Journalin lohkoon 9 kirjoitetaan sitoutumislohko.}
%%%%%     \item{Vasta 30 sekuntia myöhemmin aletaan päivittämään varsinaisia levytietorakenteita:}
%%%%%     \begin{enumerate}
%%%%%         \item{0: superlohko}
%%%%%         \item{1: lohkoryhmien kuvaajasta vähennetään vapaiden inodejen ja lohkojen määrää}
%%%%%         \item{2: lohkobittikarttaan merkitään \texttt{new}:n kirjoitetut datalohkot 9216--9231 sekä epäsuora lohko 8722 varatuksi}
%%%%%         \item{3: inodebittikarttaan merkitään \texttt{new}:lle varattu inode käytössä olevaksi}
%%%%%         \item{4: inodetaulu}
%%%%%         \item{516: juurihakemiston datalohkoon lisätään uusi hakemistoalkio \texttt{new}:lle}
%%%%%         \item{8722: epäsuora lohko}
%%%%%     \end{enumerate}
%%%%%     \item{...}
%%%%% \end{enumerate}

\section{Lokipohjaiset (``log-structured'') tiedostojärjestelmät}
\label{ChapLogStructured}
Aiemmissa luvuissa käsitellyt \texttt{ext2}/\texttt{ext3} ja Berkeley FFS ovat niin sanottuja päälle kirjoittavia tiedostojärjestelmiä (\emph{overwrite-based filesystem}~\cite{Btrfs}).
Esimerkiksi aiemmin \texttt{ext3}:n yhteydessä nähtiin kuinka olemassa olevaa tiedostoa uudelleennimettäessä
alkuperäisen tiedostonimen hakemistoalkion sisältävä sektorilta poistetaan vanha hakemistoalkio
ja vastaavasti kohdehakemistossa lisätään uusi hakemistoalkio.
Mutta koska kahden eri levylohkon päivitys atomisesti ei ole mahdollista,
täytyy \texttt{ext3}:n kirjoittaa kopiot molemmista levylohkoista journaliin kaatumistilanteen varalta.
Lokipohjaiset tiedostojärjestelmät sen sijaan kääntävät tämän tilanteen päälaelleen -- muutokset metadataan kirjoitetaan edelleen lokiin,
mutta tästä lokiin kirjoitetusta lohkosta tuleekin uusi sijainti kyseiselle metadatalle.
Tällä tekniikalla vältytään siis metadatan kahdesti kirjoittamiselta,
mutta toisaalta nyt on tarpeen tehdä päivityksiä muualla päin tiedostojärjestelmää kertomaan muokatun metadatalohkon uusi sijainti levyllä.
Tässä luvussa tutkitaan Sprite LFS:ää, joka on varhainen toteutus lokipohjaisesta tiedostojärjestelmästä.

\subsection{Sprite LFS:n periaate}
Sprite LFS on vuosina 1989--1990 kehitelty tiedostojärjestelmä Berkeleyn yliopiston kokeelliseen Sprite-käyttöjärjestelmään.
Motivaatio uuden tiedostojärjestelmän kehittämiseen oli sekä parempi kaatumisturvallisuus että suorituskyky levylle kirjoittaessa.
Perinteisiä mekaanisia kiintolevyjä käytettäessä suorituskyvyn kannalta huomioon otettavaa on niille ominainen \emph{hakuaika},
mikä tarkoittaa että levyltä useiden lohkojen lukeminen tai kirjoittaminen vie enemmän aikaa mikäli lohkot eivät sijaitse levyllä peräkkäin.
Tämän johdosta lokipohjaisten tiedostojärjestelmien levyformaatit ovatkin suunniteltu siten,
että valtaosa levykirjoituksista tehdään kirjoittamalla mahdollisimman pitkinä ja perättäisinä kirjoituksina tiedostojärjestelmän \emph{lokin} loppuun.
Erityisesti lokin `keskellä' olevien lohkojen sisältöä ei koskaan käydä uudelleenkirjoittamassa,
vaan Sprite LFS ottaa erilaisen lähestymistavan tilanteisiin jossa jotain olemassa olevaa levytietorakennetta täytyy päivittää.
Olemassa olevan levytietorakenteen sisältävän levylohkon muokkaamisen sijaan kirjoitetaan lokin loppuun uusi lohko johon haluttu muokkaus on tehty,
ja tästä uudesta lohkosta tulee uusi sijainti kyseiselle levytietorakenteelle.
Tämän mekanismin varjopuolena on tietysti että jokaisen muokkausoperaation jälkeen vanha versio levytietorakenteen sisältäneestä lohkosta jää 'kuolleeksi' viemään tilaa levyltä.
Ennen pitkää tämä kuolleiden lohkojen käyttämä tila täytyy vapauttaa takaisin tiedostojärjestelmän käyttöön,
mikä tapahtuu \emph{segmentin puhdistuksella} (\emph{segment cleaning}).

\subsection{Sprite LFS:n levyrakenne}

Sprite LFS:llä on merkittävästi yhtenäisyyksiä perinteisen Berkeley Fast Filesystem-tiedostojärjestelmän kanssa ja siten myös \texttt{ext2}:n kanssa.
Tässä luvussa selitetään pelkät eroavaisuudet luvussa~\ref{ChapExt2Fs} esiteltyihin \texttt{ext2}:n levytietorakenteisiin.
%Seuraavilta osin Sprite LFS toimii samoin kuin aiemmin luvussa~\ref{ChapExt2Fs} esitelty ext2:
%\begin{itemize}
%    \item{osoitus datalohkoihin: Kuten \texttt{ext2}:ssa, Sprite LFS:n inode pystyy viittaamaan suoraan kymmeneen datalohkoon ja tätä suuremmilla tiedostoilla käytetään epäsuorien lohkojen muodostamaa lohkopuuta.}
%    \item{hakemistojen sisältö: Kuten \texttt{ext2}:ssa, hakemistoalkiot ...}
%\end{itemize}

Valtaosa tiedostojärjestelmän sisällöstä sijaitsee lokissa (\emph{log}), joka on jaettu joko 512 kilotavun tai 1 megatavun kokoisiin \emph{segmentteihin} (\emph{segment}).
Tiedostojärjestelmän lokialueelle kirjoitetaan seuraavantyyppisiä lohkoja:

\begin{itemize}
    \item{Datalohkot: tavallisten tiedostojen tai hakemistojen sisältämä data.
        Hakemistot toimivat samalla periaatteella kuin \texttt{ext2}:ssa, eli hakemistoinoden datalohkot sisältävät hakemistoalkioita peräkkäismuodossa.}
    \item{Epäsuora lohko: toimivat samalla lailla kuin \texttt{ext2}:ssa, suurien tiedostojen datalohkoihin viitataan epäsuorien lohkojen muodostamalla lohkopuulla.}
    \item{Inodelohkot: sisältö pääosin samanlainen kuin \texttt{ext2}:n inode. Suurimpana erona on että Sprite LFS:n inoden sijaintia levyllä ei voi laskea pelkän inodenumeron avulla.}
    \item{Inodekartan (\emph{inode map}) lohkot: tietorakenne jonka avulla voidaan paikantaa inoden sijainti levyllä inodenumeron perusteella.}
    \item{Segmentin käyttöastetaulun (\emph{segment usage table}) lohkot: ylläpitää tietoa kunkin segmentin vapaiden lohkojen määrästä.}
    \item{Segmentin yhteenvetolohko (\emph{segment summary block}): kertoo segmentin sisältämien lohkojen tyypit (data vai metadata). Käytetään kaatumistilanteesta palautumisessa ja segmentin puhdistuksessa.}
    \item{Hakemistojen muutoslokilohko (\emph{directory change log block}): käytetään kaatumistilanteesta palautumiseen.}
\end{itemize}
Huomioitavaa on että \texttt{ext2}:een verrattuna inodebittikarttaa eikä lohkobittikarttaa ole.
Sprite LFS:sä inodeille ei ole erikseen varattu tilaa vaan ne sijaitsevat lokissa datalohkojen lailla
ja vapaiden lohkojen määrää ylläpidetään segmentin käyttöastetaulussa bittikartan sijaan.

Lisäksi kaksi levytietorakennetta sijaitsevat kiinteillä sijainneilla levyllä: superlohko (\emph{superblock}) sekä kaksi \emph{tarkistuspistealuetta} (\emph{checkpoint region}).
Superlohko sisältää staattista tietoa tiedostojärjestelmästä,
kuten segmentin koko ja niiden lukumäärä, eikä siihen kohdistu kirjoituksia tiedostojärjestelmän luomisen jälkeen.
Tarkistuspistealue taas kertoo miten tiedostojärjestelmän muiden tietorakenteiden senhetkiset versiot voidaan paikantaa.
Tähän sisältyy tiedostojärjestelmän inodekarttalohkojen sijainnit, segmentin käyttöastetaulun sisältävien lohkojen sisällöt sekä segmentin numeron johon lokin kirjoitus jatkuu seuraavaksi.
Koska tarkistuspistealueen koko on useita lohkoja, on tilaa varattu kahdelle tarkistuspistealueelle joihin kirjoitetaan vuorotellen.
Mikäli kaatumistilanne tapahtuu kesken tarkistuspisteen kirjoittamista, voidaan tiedostojärjestelmää liittäessä keskeneräinen tarkistuspiste havaita ja käyttää toista tarkistuspistettä.
Mikäli molemmat tarkistuspisteet ovat konsistentisti kirjoitettuja, valitaan näistä kahdesta se kumpi on uudempi.

\subsection{Esimerkki ja kaatumistilanteista palautuminen}
\label{SubsectSpriteLfsExample}

Tarkastellaan esimerkkinä tilannetta jossa luodaan tiedostojärjestelmän alihakemistoon \texttt{testdir} tiedosto \texttt{newfile} ja kirjoitetaan sinne yhden lohkon verran dataa.
Kokonaisuutena tiedostojärjestelmälle tehdään seuraavat operaatiot:

\begin{enumerate}
    \item{Hakemiston muutoslokilohko joka kertoo \texttt{testdir}:iin tapahtuvan hakemistoalkion luomisen kirjoitetaan lokiin.}
    \item{Uuden tiedoston \texttt{newfile} datalohko kirjoitetaan lokiin.}
    \item{Hakemiston \texttt{testdir} datalohkosta kirjoitetaan uusi versio lokiin johon on lisätty hakemistoalkio \texttt{newfile}.}
    \item{Uuden tiedoston \texttt{newfile} inode ja hakemiston \texttt{testdir} inodesta kirjoitetaan uusi versio,
          jossa datalohkoksi on vaihtunut edellisessä kohdassa kirjoitettu lohko. Molemmat lisätään uuteen inodelohkoon joka kirjoitetaan lokiin.}
    \item{Inodekartan lohkoista kirjoitetaan uudet versiot lokiin,
          joissa kerrotaan \texttt{newfile}:n ja \texttt{testdir}:n inodejen sijaitsevan nyt kohdassa 4 kirjoitetussa inodelohkossa.}
    \item{Segmentin käyttöastetaulun lohkoista kirjoitetaan uudet versiot lokiin,
          koska kohdissa 3.--5. tehdyt päivitykset aiheuttivat kuolleita lohkoja aiempiin lokisegmentteihin.}
    \item{Segmentin yhteenvetolohko kirjoitetaan lokiin. Yhteenvetolohko kertoo kohdissa 1.--3. kirjoitettujen lohkojen olevan datalohkoja ja kohdissa 4.--6. kirjoitettujen lohkojen olevan metadatalohkoja.}
    \item{Uusi tarkistuspiste kirjoitetaan, joka viittaa kohdissa 5. ja 6. kirjoitettuun inodekarttaan ja segmentin käyttöastetauluun.}
\end{enumerate}
%.
Lokipohjaiselle tiedostojärjestelmälle on kaksi mahdollista tekniikkaa jota käyttää kaatumistilanteista palautumiseen.
Yksinkertaisempi tekniikka on käyttää pelkkää tarkistuspisteitä palautumiseen ja monimutkaisempi mutta suorituskyvyltään parempi tekniikka on lisäksi käyttää \emph{eteenkiertopalautusta} (\emph{roll-forward recovery}).

Pelkkää tarkistuspistettä käytettäessä ei palautumisen yhteydessä tarvitse tehdä mitään tavallisesta tiedostojärjestelmän liittämisestä poikkeavaa,
eli yksinkertaisesti jatketaan tiedostojärjestelmän käyttöä uusimman kokonaan kirjoitetun tarkistuspisteen perusteella.
Mikäli kaatuminen tapahtuu ennen uuden tarkistuspisteen kirjoittamisen aloittamista eli kohtien 1.--8. välissä,
ei kyseisillä kirjoituksilla ole mitään vaikutusta sillä viimeisimmän kirjoituksia edeltäneen tarkistuspisteen näkökulmasta kyseiset kirjoitukset ovat kohdistuneet tiedostojärjestelmän vapaaseen tilaan.
Mikäli taas kaatuminen tapahtuu tarkistuspisteen kirjoittamisen aikana,
voidaan keskeneräisesti kirjoitettu tarkistuspiste tunnistaa ja samalla tavoin käyttää viimeisimmän kirjoituksia edeltänyttä tarkistuspistettä.

\subsection{Eteenkiertopalautus}

Edellisessä aliluvussa nähtiin kuinka tiedostojärjestelmään voidaan tehdä muutoksia kaatumisturvallisesti ja atomisesti kirjoittamalla uusi tarkistuspiste.
Kokonaisen tarkistuspisteen luominen vaatii kuitenkin suhteellisen monta levykirjoitusta,
joten Sprite LFS käyttää lisäksi monimutkaisempaa \emph{eteenkiertopalautusta} (\emph{roll forward recovery}) joka tuo samantasoisen kaatumisturvallisuuden mutta pienemmällä määrällä levykirjoituksia.
Eteenkiertopalautuksen perusajatuksena on lähteä liikkeelle viimeisimmästä tarkistuspisteestä samoin kuin aiemmin,
mutta tämän jälkeen aletaan lukemaan lokia eteenpäin tarkistuspisteen osoittamasta kohdasta.
Tavoitteena on viedä tiedostojärjestelmä viimeisimmästä tarkistuspisteestä tilaan,
jossa mahdollisimman paljon viimeisen tarkistuspisteen luomisen jälkeenkin tehdyistä muutoksista on toteutunut.

Tekniikan selkeänä etuna on että kaatumistilanteen aikana katoaa vähemmän meneillään olevia tiedostojärjestelmämuutoksia,
mutta myös esimerkiksi \texttt{fsync()}-operaatio voidaan nyt toteuttaa tehokkaammin.
Ilman eteenkiertoa \texttt{fsync()} vaatisi koko tarkistuspisteoperaation tekemistä,
mutta eteenkierron kanssa riittää että pelkästään tarvittavat lokikirjoitukset päätyvät levylle.
Tarvittavia levykirjoituksia voidaan vähentää vielä lisää huomioimalla että kahta Sprite LFS:n levytietorakennetta,
inodekarttaa ja segmentin käyttöastetaulua ei tarvitse kirjoittaa levylle muuten kuin tarkistuspisteen luonnin yhteydessä
sillä niihin tehtävät muutokset voidaan aina johtaa muista lokikirjoituksista eteenkiertopalautuksen aikana.
Eli esimerkiksi edellisen aliluvun~\ref{SubsectSpriteLfsExample} esimerkistä voidaan kohdat 5, 6, ja 8 lykätä tehtäväksi myöhemmin.

\subsection{Eteenkiertopalautuksen toiminta}
Eteenkiertopalautuksen aikana käydään kahdesti läpi kaikki viimeisimmän tarkistuspisteen jälkeen tehdyt lokikirjoitukset~\cite{SpriteRosenblumThesis}.
Ensimmäisellä läpikäynnillä tuodaan inodekartta ja segmentin käyttöastetaulu ajan tasalle.
Lokin läpikäynti tapahtuu segmentin yhteenvetolohkojen avulla.
Jokainen yhteenvetolohko sisältää edellisen kirjoitetun yhteenvetolohkon levyosoitteen sekä levyosoitteen johon seuraava yhteenvetolohko tullaan kirjoittamaan,
joiden avulla lokin sisällössä voidaan liikkua eteen- ja taaksepäin, tunnistaa osittain kirjoitetun segmentit sekä tunnistaa lokin loppukohta.
Lisäksi segmentin yhteenvetolohkot sisältävät viittauksen kaikkiin kyseiseen segmenttiin kirjoitettuihin inodelohkoihin,
jonka perusteella eteenkiertopalautus pystyy tekemään vastaavat päivitykset inodekarttaan.
Inodelohkojen perusteella taas voidaan johtaa tarvittavat muutokset segmentin käyttöastetauluun.
Kunkin inodelohkon sisältämän inoden uuden version lohkoviittauksia verrataan saman inoden vanhan version lohkoviittauksiin,
ja kaikki eroavaisuudet kertovat mihin segmentteihin kuolleita sivujen määrä muuttuu.

Eteenkiertopalautuksen toisella läpikäynnillä käydään läpi segmenttien sisältämät hakemistojen muutoslokilohkot.
Erillinen muutosloki tarvitaan varmistamaan että samaan aikaan kahteen eri tiedostojärjestelmän levytietorakenteeseen kohdistuvat muutokset tapahtuvat atomisesti.
Esimerkiksi uuden kovan linkin luominen vaatii vähintään kolmen tietorakenteen uuden version kirjoituksen: linkitettävän inoden kovien linkkien määrää kasvatetaan,
kohdehakemiston datalohkoihin lisätään uusi hakemistoalkio sekä kohdehakemiston inode päivitetään osoittamaan edellä mainittuun uuteen datalohkoon.
Sprite LFS ei sisällä mekanismia joka varmistaisi että kaikki vaadittavat kirjoitukset pystyttäisiin sisällyttämään osaksi samaa segmenttiä,
joten erillistä muutoslokia on käytetty tämän ongelman ratkaisemiseen.
Muutoslokiin kirjataan kaikki hakemisto-operaatiot eli tiedoston luominen, kovan linkin luominen tai poistaminen sekä uudelleennimeäminen,
ja muutoslokilohko kirjoittaan aina lokiin ennen itse inodejen ja hakemistojen datalohkojen muutoksia.
Tästä seuraa sääntö jonka perusteella eteenkiertopalautus voi tunnistaa kesken jääneet hakemisto-operaatiot.
Jos hakemistojen muutoslokissa esiintyvän hakemisto-operaation osallisena olleet inodet on kirjoitettu lokiin
vastaavan hakemiston muutoslokilohkon jälkeen,
on koko operaatio suoritettu loppuun.
Muussa tapauksessa operaatio on toteutunut joko vain osittain tai ei ollenkaan,
ja tilanteesta riippuen koko hakemisto-operaatio saatetaan loppuun tai perutaan osittain tapahtuneet muutokset.

\section{Kirjoittaessa kopioivat tiedostojärjestelmät}
\label{ChapCopyOnWrite}
\subsection{Motivaatio}
Eräs uudempi, niinikään perinteisistä päälle kirjoittavista tiedostojärjestelmistä poikkeava tekniikka on \emph{kirjoittaessa kopioivat} (\emph{CoW, Copy-on-Write}) tiedostojärjestelmät.
Merkittävimpiä kirjoittaessa kopioivia tiedostojärjestelmiä on Solaris-käyttöjärjestelmää varten suunniteltu ZFS vuodelta 2005,
sekä Linuxiin vuodesta 2007 lähtien kehityksen alla ollut Btrfs~\cite{Btrfs} johon tutustutaan tässä luvussa.

Btrfs-tiedostojärjestelmän tavoitteena on olla seuraava uuden sukupolven yleiskäyttöinen tiedostojärjestelmä jota voitaisiin käyttää kaikkialla matalatehoisista laitteista, kuten älypuhelimista palvelinsaleihin.
Verrattuna Linuxin aiempaan vakiintuneeseen \texttt{ext4}-tiedostojärjestelmään Btrfs kilpailee pääasiassa uusilla ominaisuuksilla,
joista merkittävimmät ovat tarkistussummat sekä datalle että metadatalle, \emph{tilannevedokset} (\emph{snapshot}), tiedostojen pakkaus ja usean levyn tuki.
Copy-on-write-tekniikka on keskeinen useiden edellä mainittujen ominaisuuksien kannalta.

\subsection{Btrfs:n levyrakenne}
Btrfs:n levytietorakenteet poikkeavat merkittävästi aiemmisssa luvuissa nähdyistä perinteisten Unix-tiedosto\-järjestelmien levytietorakenteista.
Superlohkoa lukuun ottamatta kaikki Btrfs-tiedostojärjestelmän metadata sijaitsee levyllä B-puuhun pohjautuvassa tietorakenteessa.
Btrfs:n kaikkien B-puiden avaimena on seuraava 17 tavun kokoinen tietorakenne \texttt{btrfs\_key}:
\begin{minted}{c}
struct btrfs_key {
    uint64_t objectid;
    uint8_t type;
    uint64_t offset;
}
\end{minted}
Jokaisella tiedostojärjestelmäobjektilla on yksilöivä tunniste \texttt{objectid},
ja B-puun sisältämiä avain-arvo-pareja käytetään oleellisesti yhdistämään mahdollisesti useita erityyppisiä tietueita avaimen \texttt{objectid}-kentän osoittamaan tiedostojärjestelmäobjektiin.
Avaimen \texttt{type}-kenttä kertoo tietueen tyypin ja \texttt{offset}-kenttä tietueiden järjestyksen samantyyppisten tietueiden välillä.

% Suurin osa perinteisistä tiedostojärjestelmän tietorakenteista sijaitsee \emph{alitaltiopuussa} (\emph{subvolume tree}),
% josta löytyvät sekä inodet, hakemistoalkiot että viittaukset tiedoston dataan.
Kutakin tiedostojärjestelmän inodea vastaa yksi avain-arvo-pari tyyppiä \texttt{INODE\_ITEM} jossa \texttt{objectid} sisältä inoden numeron, \texttt{offset}-kenttää ei käytetä ja alkion arvo sisältää tyypilliset inoden attribuutit kuten koon, käyttöoikeudet ja aikaleimat.
Hakemistojen sisältö ilmaistaan liittämällä hakemistoinodeen \texttt{DIR\_ITEM}-tyyppinen avain-arvo-pari jokaista hakemistoalkiota kohden.
Koska B-puun avaimilla on kiinteä pituus, ei tiedostonimeä voida lisätä osaksi avainta,
vaan tiedostonimestä lasketaan 64-bittinen hajautusarvo joka sisällytetään \texttt{offset}-kenttään ja arvo sisältää itse tiedostonimen ja inodenumeron.
Tällä tavoin yksittäisen tiedostonimen paikannus hakemistosta voidaan edelleen tehdä yhdellä B-puu-kyselyllä vaikka tiedostonimien listaus aakkosjärjestyksessä tai osavälikyselyt eivät ole mahdollisia.

Inoden datalohkoihin viitataan lohkopuun sijaan \emph{extent}-tietueilla.
Yksi extent-tietue on oleellisesti pari \texttt{(alkulohko, pituus)} jolla voidaan kerralla kuvata useampi tiedoston datalohko perättäisiin fyysisiin lohkoihin levyllä.
Siis esimerkiksi tilanteessa jossa tiedoston data sijaitsee tuhannella perättäisellä levylohkolla,
voidaan tämä kuvaus esittää yhdellä extent-tietueella kun taas lohkopuuta käyttäessä jokainen lohko vaatii yhden alkion per lohko, eli yhteensä 1000 alkiota.
Pienien tiedostojen sisältö on myös mahdollista säilyttää suoraan B-puun lehtisivun sisällä,
mikä välttää hukkatilan syntymisen tilanteissa missä tiedoston koko on tiedostojärjestelmän lohkokokoa pienempi.

\subsection{Levyrakenteiden päivitys copy-on-write-tekniikalla}
Kuten aiemmin nähtiin, kaikki tiedostojärjestelmäoperaatiot ovat oleellisesti vain muokkauksia tiedostojärjestelmän pohjalla olevana B-puu-tietorakenteeseen.
Muutoksien vieminen levylle palautuukin siis oleellisesti B-puun levyversion päivittämiseen kaatumisturvallisesti.
Tähän Btrfs käyttää kirjoittaessa kopioivaa tekniikkaa,
jonka perusajatuksena on että levylle aiemmin kirjoitettuja datalohkoja tai B-puun lohkoja ei ylikirjoiteta niitä muokattaessa,
vaan niistä kirjoitetaan aina uudet kopiot tiedostojärjestelmän vapaille lohkoille.
Lohkon kirjoituksesta aiheutuvan kopioinnin seurauksena kaikki viittaukset lohkon vanhaan sijaintiin täytyy päivittää viittaamaan lohkon uuteen sijaintiin,
mikä aiheuttaa lisää kirjoittaessa kopiointia.
Prosessia jatketaan B-puun lehdistä ylöspäin taso kerrallaan,
kunnes koko tiedostojärjestelmää kuvaavan B-puun juuresta on kirjoitettu uusi kopio.
Lopuksi tiedostojärjestelmän superlohko päivitetään osoittamaan uuteen B-puun juureen,
mikä onkin tiedostojärjestelmän ainoa tietorakenne jota päivitetään päällekirjoituksilla.

\section{Kirjoitusjärjestyksen hallintaan perustuvat tiedostojärjestelmät (``soft updates'')}
\label{ChapSoftUpdates}
Aiemmissa luvuissa esiteltiin tekniikoita,
jossa tiedostojärjestelmän konsistenssiuden säilyminen kaatumistilanteessa varmistettiin oleellisesti toteuttamalla tiedostojärjestelmään jokin menetelmä metadatapäivitysten tekemiseen atomisesti.
Vaihtoehtoisia lähestymistapojakin on kuitenkin käytetty,
joista yksi on \emph{pehmeät päivitykset} (\emph{soft updates}) jotka perustuvat metadatakirjoitusten tekemiseen tietyssä järjestyksessä.
Tarkastellaankin seuraavaksi pehmeiden päivitysten toteutusta Berkeley Fast Filesystem-tiedostojärjestelmä~\cite{SoftUpdatesFfs}.
%Pehmeiden päivitysten pääperiaatteena on käyttää edelleen FFS:n levyformaattia,
%mutta tehdä päivitykset levytietorakenteisiin järjestyksessä jossa tiedostojärjestelmä säilyy mahdollisimman konsistenttina.
%\texttt{ext2}:sta poiketen FFS-tiedostojärjestelmälle ei löydy tukea Linuxista, vaan tarkasteltavana on toteutus 90-luvun BSD 4.4-käyttöjärjestelmästä.

\subsection{Berkeley Fast Filesystem-tiedostojärjestelmä}
Berkeley Fast Filesystem (FFS) on alkuperäiseeen BSD-käyttöjärjestelmään kehitetty varsin varhainen Unix-tiedostojärjestelmä.
Koska aiemmin esitelty \texttt{ext2} on ottanut vaikutteita FFS-tiedostojärjestelmästä,
muistuttavat niiden levytietorakenteet vahvasti toisiaan.
Pääpiirteissään jokaiselle \texttt{ext2}:n levytietorakenteelle löytyy suora vastine FFS:tä,
joten kaatumistilanteella on FFS:lle samanlaiset seuraukset kuin mitä \texttt{ext2}:lle nähtiin luvussa~\ref{ChapExt2Crash}.
Erityisesti \texttt{fsck}-tarkastusohjelman ajaminen kaatumistilanteen jälkeen oli tarpeen ennen kuin tiedostojärjestelmää pystyttiin käyttämään.
FFS-tiedostojärjestelmän kaatumisturvallisuutta alettiin parantamaan alkaen BSD-käyttöjärjestelmän versiosta 4.4, joka julkaistiin vuonna 1995.
Käytettäväksi menetelmäksi valittiin \emph{pehmeät päivitykset} (\emph{soft updates}).
Verrattuna muihin kilpaileviin tekniikoihin kuten journalointiin tai lokipohjaisiin tiedostojärjestelmiin,
pehmeät päivitykset eivät edellytä mitään muutoksia tai lisäyksiä tiedostojärjestelmän levyformaattiin.
Sen sijaan pehmeät päivitykset perustuvat levykirjoitusten tekemiseen aina sellaisessa järjestyksessä jossa kaatumistilanteet eivät voi aiheuttaa merkittäviä epäkonsistenssiuksia tiedostojärjestelmän metadataan,
jolloin \texttt{fsck}-ohjelman ajaminen kaatumistilanteen jälkeen ei ole enää tarpeen.

\subsection{Pehmeät päivitykset ja \emph{päivitysriippuvuudet}}
Aiemmin aliluvussa~\ref{ChapExt2FileCreation} esiteltiin mahdollisia epäkonsistenssiuksia joita \texttt{ext2}-tiedostojärjestelmään voi syntyä mikäli kaatumistilanne tapahtuu kutsun \texttt{creat("new", 0755)} aikana.
Tarkastellaan nyt miten pehmeitä päivityksiä käyttäen vältytään merkittävimmiltä epäkonsistenssiuksilta kirjoitusjärjestystä muuttamalla.

FFS-tiedostojärjestelmän tapauksessa muokataan samoja levytietorakenteita,
mutta pehmeitä päivityksiä käytettäessä levykirjoitusten järjestys voisi olla seuraava:
% 90-luvun BSD 4.4-käyttöjärjestelmästä löytyvä Berkeley Fast Filesystem-tiedostojärjestelmä~\cite{SoftUpdatesFfs}.
\begin{enumerate}
    \item{Lohkoryhmän kuvaajat}
    \item{Lohkoryhmän inodebittikartta}
    \item{Inodetaulu}
    \item{Hakemistoalkio}
    % sylinteriryhmä?
    % superlohko?
\end{enumerate}
%
Tässä järjestyksessä tehtynä kaatuminen ei milloinkaan johda tilanteeseen jossa tiedostojärjestelmän käytön jatkaminen ei olisi turvallista.
Ainoastaan kohtien 1--2 tai 2--3 välissä tapahtunut kaatuminen johtaa yhden inoden vuotamiseen.
Sallittuja kirjoitusjärjestyksiä on yleensä useita, tässä esimerkissä kohdat 1. ja 2. voisivat vaihtaa paikkaa ilman ongelmia.
Kriittisintä on, että uuteen inodeen viittaavaa tietorakennetta (eli tässä tapauksessa hakemistoalkiota) ei kirjoiteta levylle ennen kuin itse inoden tietorakenne on alustettu ja merkattu käytössä olevaksi bittikarttaan.
Tämäntyyppisiä kirjoitusjärjestystä koskevia rajoituksia (``päivitys metadatalohkoon tyyppiä $x$ täytyy kirjoittaa levylle ennen päivitystä metadatalohkoon tyyppiä $y$'') kutsutaan \emph{päivitysriippuvuuksiksi} (\emph{update dependency}).
Niin kauan kuin muokkaukset tiedostojärjestelmän levytietorakenteisiin tehdään päivitysriippuvuuksien sallimassa järjestyksessä,
eivät kaatumistilanteet aiheuta pahoja epäkonsistenssiuksia.

\subsection{Päivitysriippuvuudet}
% FFS-tiedostojärjestelmän päivitysriippuvuudet voidaan johtaa muutamasta perusperiaatteesta.
% FFS-tiedostojärjestelmän tapauksessa resursseja ovat inodet ja datalohkot.
% Viittauksia inodeihin syntyy hakemisto
% Datalohkon sisältö täytyy kirjoittaa levylle ennen kuin inodelohkoon tai epäsuoraan lohkoon lisätään viittaus datalohkoon.

% Yleistämällä tämä periaate saadaan joukko sääntöjä:
    %\item{Uutta resurssia (joko inode tai datalohko) varattaessa resurssi täytyy alustaa ennen kuin resurssiin lisätään viittaus.}
    %\item{Uutta resurssia (joko inode tai datalohko) varattaessa resurssi täytyy merkitä varatuksi bittikartassa ennen kuin resurssiin lisätään viittaus.}
    %\item{Uutta resurssia (joko inode tai datalohko) varattaessa resurssi täytyy merkitä varatuksi bittikartassa ennen kuin resurssiin lisätään viittaus.}

Uutta tiedostoa luodessa:
\begin{itemize}
    \item{Inode täytyy merkitä varatuksi inodebittikartassa ennen kuin inoden levytietorakenne alustetaan inodetaulussa.}
    \item{Inoden levytietorakenne täytyy alustaa ennen kuin hakemistolohkoon lisätään hakemistoalkio viittaamaan uuden tiedoston inodeen.}
    \item{Uutta hakemistoa luodessa täytyy lisäksi varata ja alustaa datalohko hakemiston sisällölle.}
\end{itemize}
Uutta kovaa linkkiä luodessa:
\begin{itemize}
    \item{Inodeen viittaavien hakemistoalkioiden lukumäärää täytyy kasvattaa inodessa ennen kuin hakemistolohkoon lisätään uusi hakemistoalkio inodelle.}
\end{itemize}
Tiedostoon lohkoja lisättäessä:
\begin{itemize}
    \item{Datalohkon sisältö täytyy kirjoittaa levylle ennen kuin epäsuoraan lohkoon tai inodeen lisätään viittaus datalohkoon.}
    \item{Datalohko täytyy merkitä varatuksi lohkobittikartassa ennen kuin epäsuoraan lohkoon tai inodeen lisätään viittaus datalohkoon.}
    \item{Mikäli lohkojen lisääminen vaatisi uusien epäsuorien lohkojen varaamista, sovelletaan kahta edellistä uuden epäsuoran lohkon varaamisessa ja lohkopuuhun liittämisessä.}
\end{itemize}
Kovaa linkkiä poistaessa:
\begin{itemize}
    \item{Hakemistoalkio täytyy poistaa hakemistolohkosta ennen kuin inodeen viittaavien nimien lukumäärää vähennetään inodessa.}
\end{itemize}
Lohkojen poistaminen tiedostosta:
\begin{itemize}
    \item{Lohkoja ei voida vapauttaa lohkobittikartasta ennen kuin viittaukset datalohkoihin ovat nollattu inoderakenteesta tai epäsuorasta lohkosta.}
    \item{Lohkoja ei voida uudelleenkäyttää ennen kuin viittaukset datalohkoihin ovat nollattu inoderakenteesta tai epäsuorasta lohkosta.}
\end{itemize}
Tiedostoa poistettaessa:
\begin{itemize}
    \item{Hakemistoalkio täytyy poistaa hakemistolohkosta ennen kuin inoden rakenne nollataan.}
    %\item{Hakemistoalkio täytyy poistaa hakemistolohkosta ennen kuin inode merkitään vapautetuksi inodebittikartassa.}
    \item{Poistetun tiedoston inodea ei voida vapauttaa inodebittikartasta ennen kuin inoden rakenne on nollattu.}
    \item{Poistetun tiedoston inodea ei voida uudelleenkäyttää ennen kuin kaikki siihen viittaavat hakemistoalkiot on poistettu ja hakemistoalkioiden sisältämät hakemistolohkot kirjoitettu levylle.}
\end{itemize}

% Ennen kuin lohkoon lisätään viittaus joko epäsuoran lohkoon tai inoden kautta on 
% Datalohkon sisällön kirjoitus täytyy tapahtua ennen kuin viittaus kyseiseen lohkoon lisätään joko epäsuoraan lohkoon tai inodeen.

\subsection{Sykliset riippuvuudet}
Pehmeiden päivitysten ja levyvälimuistien yhdistelmällä voidaan joutua tilanteeseen jossa tietorakenteiden väliset riippuvuudet muodostavat syklin.
Otetaan esimerkiksi lähtötilanne,
jossa muuten tyhjässä tiedostojärjestelmässä on pelkästään yksi tyhjä tiedosto \texttt{/oldfile} ja sille tehdään seuraavat operaatiot:
%
\begin{minted}{c}
open("/newfile", O_CREAT | O_WRONLY, 0644);
unlink("/oldfile");
\end{minted}
%
Oletetaan lisäksi että sekä \texttt{newfile}:n että \texttt{oldfile}:n inodet päätyvät samalle inodelohkolle ja hakemistoalkiot samalle hakemiston lohkolle.
Nyt tiedostojärjestelmän osalta ovat voimassa seuraavat päivitysriippuvuudet:
\begin{enumerate}
    % inode <- dir
    \item{inodelohko täytyy kirjoittaa ennen hakemistolohkoa, jotta \texttt{newfile}:n hakemistoalkio ei osoita alustamattomaan inodeen.}
    % bitmap <- inode
    \item{inode\-bitti\-kartan lohko täytyy kirjoittaa ennen inode\-lohkoa, jotta \texttt{newfile}:n inodea ei alusteta ennen kuin se on varattu bittikartassa.}
    % dir <- inode
    \item{hakemisto\-lohko täytyy kirjoittaa ennen inode\-lohkoa, jotta \texttt{oldfile}:n hakemisto\-alkio ei osoita vapautettuun inodeen.}
    % inode <- bitmap
    \item{inode\-lohko täytyy kirjoittaa ennen inode\-bitti\-kartan lohkoa, jotta \texttt{oldfile}:n inode ei ole samanaikaisesti alustettuna inodetaulussa ja vapaana bitti\-kartassa.}
\end{enumerate}
Näistä päivitysriippuvuuksista 1. ja 3. muodostavat syklisen riippuvuuden inodelohkon ja hakemistolohkon välillä ja päivitysriippuvuudet 2. ja 4. muodostavat syklin inodelohkon ja inodebittikarttalohkon välillä.
On siis päädytty tilanteeseen, jossa mitään metadatalohkoa ei voida sellaisenaan kirjoittaa levylle ilman että jokin päivitysriippuvuus jää täyttämättä.

Pehmeiden päivitysten ratkaisu sykleihin on väliaikaisesti perua päivitysriippuvuuden aiheuttanut muutos metadatalohkoon ennen sen kirjoittamista levylle.
Siis käyttöjärjestelmä voi kirjoittaa levylle minkä tahansa muokatun metadatalohkon,
mutta täyttämättömien päivitysriippuvuuksien tapauksessa perutaan muutos väliaikaisesti.
Esimerkiksi edellä nähdyistä päivitysriippuvuuksista kukin voidaan perua seuraavasti: TODO.
% XXX

Käyttäen perumisinformaatiota metadatapäivitykset voidaan viedä esimerkiksi seuraavassa järjestyksessä:
\begin{enumerate}
    \item{inodelohkosta kirjoitetaan versio,
          jossa \texttt{oldfile}:n inoden poistaminen on kumottu.}
    \item{inodebittikartan lohkosta kirjoitetaan versio,
          jossa \texttt{oldfile}:n inoden vapautus on kumottu.}
    \item{hakemistolohkon lopullinen versio kirjoitetaan.}
    \item{inodelohkon lopullinen versio kirjoitetaan.}
    \item{inodebittikartan lohkon lopullinen versio kirjoitetaan.}
\end{enumerate}

% init state: /oldfile
% - creat(/newfile)
% - unlink(/oldfile)
% dirty:
% - / dirents
% - inode bitmap (+newfile -oldfile)
% deps:
% - dirents before oldfile
% - newfile inode before dirents
% - inode bitmap before dirents
% - dirents before inode bitmap

% init state: /oldfile[oldblk1]
% - creat(/newfile)
% - write(/newfile[newblk2])
% - unlink(/oldfile)
% dirty:
% - / dirents
% - inode bitmap (+newfile -oldfile)
% - block bitmap (+newblk1 -oldblk1)
% - newfile inode
% - oldfile inode
% deps:
% oldfile inode before block bitmap
% dirents before oldfile inode
% newfile inode before dirents
% block bitmap before newfile inode

\subsection{Kaatumistilanteesta palautuminen}
Pehmeiden päivityksiä käyttäessä palautumista ei tarvitse tehdä ennen tiedostojärjestelmän liittämistä,
sillä kaikki metadatakirjoitukset on tehty järjestyksessä jossa levyrakenteisiin ei synny kriittisiä epäkonsistenssiuksia.
Kaatumistilanteen seurauksena tiedostojärjestelmään voi kuitenkin aiheutua seuraavia ei-kriittisiä ongelmia:
\begin{itemize}
    \item{Datalohkoja jotka on merkitty varatuksi lohkobittikartassa, mutta joihin ei ole viittausta mistään inodesta.}
    \item{Käytössä olevia inodeja jotka eivät ole yhteydessä hakemistorakenteeseen.}
    \item{Käytössä olevia inodeja joihin on todellisuudessa vähemmän viittauksia hakemistoalkioiden kautta kuin mitä inodetietorakenteen laskuri osoittaa.}
\end{itemize}
Mikään näistä ei estä tiedostojärjestelmän käytön jatkamista turvallisesti vaan näkyy käyttäjälle pääasiassa ``vuotaneina'' resursseina,
eli tiedostojärjestelmässä on näennäisesti vähemmän vapaata tilaa tai inodeja kuin siellä pitäisi olla.
Ennen pitkää nämä ongelmat täytyy kuitenkin korjata,
jotta vuotaneen levytilan osuus ei kasva suuremmaksi jokaisen kaatumistilanteen seurauksena.
Tämä on toteutettu mahdollistamalla \texttt{fsck}-tarkistusohjelman ajamisen taustalla.

\section{Yhteenveto}
Tutkielmassa tarkasteltiin kaatumistilanteita Unix-tiedostojärjestelmissä alkaen POSIX-tiedostojärjestelmärajapintojen perusteista.
Vaikka tiedostojärjestelmää käyttävän sovelluksen toteuttaminen onnistuu aloittelevalta ohjelmoijaltakin,
paljastui ettei kaatumisturvallisen ohjelman toteutus olekaan enää yksinkertaista.
%... , joten abstraktio epäonnistuu.
Tilannetta monimutkaistaa entisestään se,
että eri tiedostojärjestelmät käyttäytyvät kaatumistilanteissa eri tavalla.

Myös muutaman tiedostojärjestelmän sisäiseen rakenteeseen perehdyttiin lähtien liikkeelle perinteisestä mutta yksinkertaisesta \texttt{ext2}:sta.
Kaatumistilanteita simuloimalla QEMU-virtuaalikoneella pystyttiin näyttämään käytännössä mitä seurauksia kaatumistilanteilla on \texttt{ext2}:n levyrakenteille
ja toisaalta myös havainnollistamaan levyvälimuistien vaikutusta levykirjoituksiin.
Tällä pystyttiin osoittamaan,
että \texttt{ext2}-tiedostojärjestelmää käytettäessä jokaisen kaatumistilanteen jälkeen on pakko ajaa \texttt{e2fsck}-tarkastusohjelma,
tai muuten on olemassa riski että koko tiedostojärjestelmä korruptoituu pidemmälle.
Lopuksi esiteltiin eri tekniikoita,
joilla modernimmat tiedostojärjestelmät säilyvät konsistenssina kaatumistilanteiden aikanakin.
% Valtaosa tekniikoista perustui atomisiin tekniikoihin ...

\texttt{ext2}:sta.
