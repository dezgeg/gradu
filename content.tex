\section{Johdanto}

\section{POSIX-tiedostojärjestelmärajapinnat}

Aikoinaan oli käytössä useita Unix-pohjaisia käyttöjärjestelmiä jotka olivat periaatteessa samankaltaisia mutta käytännössä toimivat hieman eri tavalla.
Sovellusohjelmoijan kannalta tämä hankaloitti huomattavasti monella eri Unix-järjestelmällä toivivien ohjelmien toteutusta.
Tämän ratkaisemiseksi kehiteltiin POSIX-standardi~\ref{PosixSpec} yhtenäistämään eri Unix-toteutusten tarjoamat rajapinnat.
Ensimmäinen versio standardista julkaistiin vuonna 1988.
POSIX-standardi määrittelee muun muassa komentorivityökaluja sekä C-kielisiä rajapintoja muun muassa tiedostojen, säikeiden ja prosessien hallintaan.
Käytännössä mitään Linux-jakelua ei virallisesti ole sertifioitu POSIX-yhteensopivaksi,
mutta käytännössä kehittäjät tähtäävät POSIX-yhteensopivuuteen.

Luotettavien ja kaatumisen kestävien sovellusten luominen POSIXissa on suhteellisen monimutkaista.
Esitelläänkin seuraavaksi POSIXin tarjoamat C-rajapinnat tiedostojen käsittelyyn.

\subsection{Tiedostonimet}
POSIX-tiedostojärjestelmät tukevat hakemistoja, eli tiedostojärjestelmä muodostaa hierarkisen puurakenteen.
Tiedostopoluissa hakemistojen erottimena toimii kauttaviiva eli \texttt{/}-merkki.
\texttt{/}-merkillä alkavat tiedostopolut ovat \emph{absoluuttisia} polkuja,
muut polut ovat \emph{suhteellisia} polkuja.
Jokaisella ajonaikaisella prosessilla on oma nykyinen hakemistonsa (current directory),
jonka suhteen suhteelliset polut tulkitaan.
Esimerkiksi prosessilla jonka nykyinen hakemisto on \texttt{/home/tuomas},
viittaisi polku \texttt{Downloads/kuva.jpg} tiedostoon \texttt{/home/tuomas/Downloads/kuva.jpg}.
POSIXissa on kaksi erityistä tiedostonimeä: \texttt{.} ja \texttt{..} joiden voidaan mieltää löytyvän jokaisesta hakemistosta.
Näistä \texttt{.} viittaa aina siihen hakemistoon jossa se sijaitsee,
esimerkiksi polku \texttt{/home/tuomas/.} viittaa samaan hakemistoon kuin polku \texttt{/home/tuomas}.
Niinikään \texttt{.}-nimeä voi käyttää missä tahansa kohtaa polkua,
eli esimerkiksi \texttt{/home/./tuomas} tai \texttt{/home/././tuomas/././.} viittaavat edelleen samaan hakemistoon.
Nimi \texttt{..} taas viittaa ylempään tasoon hakemistorakenteessa.

\subsection{Tiedoston avaus ja sulkeminen}
Tiedoston avaus tapahtuu \texttt{open}-funktiolla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html#tag_16_357
\begin{verbatim}
int open(const char *path, int oflag, ...);
\end{verbatim}

Parametri \texttt{path} on tiedoston polku merkkijonona
ja \texttt{oflag} on kasa lippuja jotka määräävät miten tiedosto avataan.
Yksi lipuista \texttt{O\_RDONLY}, \texttt{O\_WRONLY} ja \texttt{O\_RDWR} on pakko antaa.
Ne määräävät avataanko tiedosto vain lukua, vain kirjoitusta tai sekä lukua että
kirjoitusta varten.
Muita mahdollisia lippuja on esimerkiksi \texttt{O\_TRUNC},
joka tyhjentään tiedoston sisällön (truncate).
Tiedoston voi myös luoda antamalla lipun \texttt{O\_CREAT},
jolloin kolmas parametri määrittelee luodun tiedoston oikeudet.
Funktio palauttaa onnistuessaan \texttt{int}-tyyppisen \emph{tiedostokahvan},
joka viittaa kyseiseen avattuun tiedostoon.
Tiedostokahvat ovat prosessikohtaisia,
eli yrittämällä lukea samalla tiedostokahvan numeerisella arvolla
jossakin toisessa prosessissa tapahtuu jotain odottomatonta.

Tiedoston sulkeminen tapahtuu \texttt{close}-funktiolla,
jolle annetaan auki oleva tiedostokahva ainoana parametrina:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html#tag_16_67
\begin{verbatim}
int close(int fildes);
\end{verbatim}

\subsection{Tiedoston luku ja kirjoitus}

Tiedostosta luku ja tiedostoon kirjoitus tapahtuu ohjelmoijan näkökulmasta suhteellisen
samalla tavalla, funktioilla \texttt{read} ja \texttt{write}:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html#tag_16_474
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html#tag_16_685
\begin{verbatim}
ssize_t read(int fildes, void *buf, size_t nbyte);
ssize_t write(int fildes, const void *buf, size_t nbyte);
\end{verbatim}

Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
\texttt{buf} on osoitin \texttt{nbyte} tavun kokoiseen puskuriin johon
luetaan tai josta kirjoitetaan.
Onnistuessaan funktiot palauttavat kuinka monta tavua luettiin tai kirjoitettiin.
Paluuarvo voi siis olla pienempi kuin mitä ohjelma pyysi lukemaan tai kirjoittamaan,
esimerkiksi jos kirjoittaessa levy täyttyi kesken tai luettaessa
tiedosto loppui kesken.

Jokaisella tavalliseen tiedostoon viittaavalla tiedostokahvalla on
sijainti tavuina missä kohtaa tiedostoa ollaan ja josta
lukeminen tai kirjoittaminen aloitetaan.
Onnistuessaan sijainti tiedostossa siirtyy eteenpäin paluuarvon verran.

Tiedostokahvan sijainnin voi selvittää ja sijaintia tiedostossa voi
siirtää \texttt{lseek}-kutsulla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html#tag_16_310
\begin{verbatim}
off_t lseek(int fildes, off_t offset, int whence);
\end{verbatim}

Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
Kolmas parametri \texttt{whence} kertoo miten \texttt{offset}-parametri tulkitaan:

\begin{itemize}
    \item Arvo \texttt{SEEK\_SET} asettaa kahvan sijainniksi \texttt{offset}.
    \item Arvo \texttt{SEEK\_CUR} siirtää kahvaa eteenpäin \texttt{offset} tavua.
    \item Arvo \texttt{SEEK\_END} siirtää kahvan \texttt{offset} tavua eteenpäin laskien tiedoston lopusta.
\end{itemize}

Onnistuessaan kutsu palauttaa sijainnin johon siirryttiin.
Sijainnin voi siis selvittää siirtymättä tiedostossa kutsulla \texttt{lseek(fd, , SEEK\_CUR)}.

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html#tag_16_173
\begin{verbatim}
int fstat(int fildes, struct stat *buf);
\end{verbatim}

% dev_t st_dev            Device ID of device containing file
% ino_t st_ino            File serial number.
% mode_t st_mode          Mode of file (see below).
% nlink_t st_nlink        Number of hard links to the file.
% uid_t st_uid            User ID of file.
% gid_t st_gid            Group ID of file.
% dev_t st_rdev           Device ID (if file is character or block special).
% off_t st_size           For regular files, the file size in bytes.
%                         For symbolic links, the length in bytes of the
%                         pathname contained in the symbolic link.
% struct timespec st_atim Last data access timestamp.
% struct timespec st_mtim Last data modification timestamp.
% struct timespec st_ctim Last file status change timestamp.
% blksize_t st_blksize    A file system-specific preferred I/O block size
%                         for this object. In some file system types, this
%                         may vary from file to file.
% blkcnt_t st_blocks      Number of blocks allocated for this object.
%
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/chmod.html#tag_16_58
\begin{verbatim}
int chmod(const char *path, mode_t mode);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html#tag_16_59
\begin{verbatim}
int chown(const char *path, uid_t owner, gid_t group);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html#tag_16_293
\begin{verbatim}
int link(const char *path1, const char *path2);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html#tag_16_635
\begin{verbatim}
int unlink(const char *path);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html#tag_16_487
\begin{verbatim}
int rename(const char *old, const char *new);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html#tag_16_475
\begin{verbatim}
struct dirent *readdir(DIR *dirp);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html#tag_16_476
\begin{verbatim}
ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html
\begin{verbatim}
int ftruncate(int fildes, off_t length);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdopendir.html#tag_16_127
\begin{verbatim}
DIR *opendir(const char *dirname);
\end{verbatim}

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/closedir.html
\begin{verbatim}
int closedir(DIR *dirp);
\end{verbatim}

\section{POSIX ja levyvälimuistit}
Tietokoneiden massamuistit ovat tyypillisesti keskusmuistia merkittävästi hitaampia lukea ja kirjoittaa.
Tyypillinen tapa parantaa tiedostojärjestelmän suorituskykyä onkin käyttää osaa keskusmuistista välimuistina tiedostojärjestelmälle.
POSIX-standardi antaakin tiedostojärjestelmätoteutuksille merkittäviä vapauksia erilaisten välimuistien käyttöön,
joita muun muassa Linux hyödyntää merkittävissä määrin.
Kyseisenkaltaisilla optimoinneilla on kuitenkin varjopuolensa,
sillä ne hankaloittavat kaatumistilanteita kestävien sovellusten, kuten tietokantajärjestelmien toteuttamista.
Tässä luvussa tarkastellaankin POSIXin tarjoamia rajapintoja tiedostojärjestelmän välimuistien hallintaan sekä muita sovellusohjelmoijan kannalta huomioonotettavia seikkoja.

Unix-käyttöjärjestelmissä on tyypillisesti jo pitkään toteutettu välimuisti levylohkoille (buffer cache).
Tämänkaltainen pelkkiä levylukuja säilyttävä välimuisti ei näy sovellusohjelmoijalle mitenkään.
Tästä looginen seuraus on kirjoitusten vieminen välimuistiinn.
Tämä voidaan tehdä sekä tiedoston metadatalle että varsinaiselle datalle.
Siis sekä datan kirjoitus \texttt{write()}-funktiolla että
tiedoston metadataa muokkaavat operaatiot,
mukaanlukien aikaleimojen päivitykset eivät välttämättä päädy levylle asti tiedostojärjestelmäkutsun palatessa.

Levyvälimuistin hallintaan löytyy POSIXissa kaksi keskeistä funktiota.

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html
\begin{verbatim}
int fsync(int fildes);
int fdatasync(int fildes);
\end{verbatim}

Operaatio \texttt{fdatasync()} pakottaa parametrina annettua tiedostokahvaa \texttt{fildes} vastaavan tiedoston levyvälimuistin kirjoittamisen.
Funktiokutsu ei palaa kunnes data on turvallisesti kirjoitettu levylle.
\texttt{fdatasync()}-kutsu ei vaikuta tiedoston metadataan muuten kuin että kutsun onnistuessa taataan että tiedostoon tähän asti tehdyt kirjoitukset ovat luettavissa kaatumisen jälkeenkin.
Käytännössä käyttäjän näkokulmasta tämä takaa vain että tiedoston koko on ajan tasalla.
Funktio \texttt{fsync()} on vahvempi versio \texttt{fdatasync()}:stä joka lisäksi pakottaa kaiken tiedoston viittaavan inoden metadatan kirjoitettavan levylle.
Lisäksi on varmistettava erikseen että tiedoston inodeen viittaavat tiedostonimet ovat kirjoitettu pysyvästi levylle.
Tämä tapahtuu kutsumalla \texttt{fsync()}-funktiota hakemistolle jossa tiedostonimi sijaitsee.

\section{ext2:n rakenne}
ext2 (``Second extended filesystem'')  on tiedostojärjestelmä joka on luotu jo Linuxin alkuaikoina, vuonna 1993.
Ennen ext2:ta Linux käytti MINIX-tiedostojärjestelmää,
joka oli yksinkertainen mutta sisälsi erinäisiä rajoitteita jotka alkoivat haittaamaan.
Esimerkiksi MINIX-tiedostojärjestelmässä tiedostonimen pituus oli rajoitettu 14 merkkiin
ja tiedoston koko 64 megatavuun.
Ext2 ei ainoastaan korjaa näitä puutteeita,
mutta on lisäksi suunniteltu siten että tiedostojärjelmän levyformaattia voidaan laajentaa taaksepäin yhteensopivasti.
Ext2:lle onkin kehitetty seuraajat ext3 ja ext4 joissa olemassaoleva ext2- tai ext3-osio voidaan päivittää seuraavaan
ext:n versioon ilman tiedostojärjestelmän uudelleenformatointia.
Erityisesti mainittakoon ext3:n tuoma kirjaus, joka parantaa merkittävästi ext2:n kykyä säilyä konsistenttina kaatumistilanteessa.
Kirjaavia tiedostojärjestelmiä käsitelläänkin myöhemmin luvussa X.

Tässä luvussa tarkastellaan ext2:n rakennetta levyllä.
Tiedostojärjestelmän levyrakenne vaikuttaa olennaisesti siihen minkälaisia epäkonsistenttiuksia tiedostojärjestelmään voi syntyä virhetilanteissa.
Yleisesti ottaen ext2:n rakenne on varsin suoraviivainen tapa toteuttaa Unix-tyylinen tiedostojärjestelmä ja se muistuttaakin hyvin pitkälti muita aikaisia Unix-tiedostojärjestelmätoteutuksia, kuten Berkeley Fast Filesystem.
Siksi ymmärrys ext2:sta auttaa merkittävästi muidenkin tiedostojärjestelmien ymmärtämisessä.

Ext2:n levyrakenne korkealla tasolla on esitetty kuvaajassa \ref{ext2_disk_format}.

\begin{figure}
    \label{ext2_disk_format}
    \includegraphics[width=1.0\textwidth]{gfx/ext2-structure.pdf}
    \caption{Ext2:n rakenne levyllä.}
\end{figure}

Korkeimmalla tasolla ext2:n rakenne on jaettu kahteen osaan: on \emph{käynnistyslohkoon} sekä useisiin \emph{lohkoryhmiin}.
Käynnistyslohkon tarkoitus on yksinkertaisesti varattua tilaa jollekin ext2:ta riippumattomalle käynnistyslataajalle,
itse tiedostojärjestelmä ei käytä tätä tilaa mitenkään.
Valtaosa ext2:n levynkäytöstä on lohkoryhmiä,
joista jokainen lohkoryhmä viimeistä lukuunottamatta vie yhtä paljon tilaa levyltä.
Jokainen ext2:n lohkoryhmä on puolestaan jaettu seuraaviin tietorakenteisiin:
\emph{superlohkoon} (superblock), 
\emph{lohkoryhmien kuvaajiin} (block group descriptors),
\emph{lohkobittikarttoihin} (block bitmap),
\emph{inodebittikarttoihin} (inode bitap),
\emph{inodetauluun} (inode table) sekä datalohkoihin.
Näistä superlohko ja lohkoryhmien kuvaajat ovat koko tiedostojärjestelmälle yhtenäistä metadataa,
joiden periaatteessa riittäisi olla levyllä vain kerran,
ja itse asiassa Linux-ajuri käyttääkin vain ensimmäisestä lohkoryhmästä löytyviä rakenteita.
Ext2:ssa on kuitenkin molemmista tietorakenteista on kopio jokaisessa lohkoryhmässä korruptoitumisen varalta.

\subsection{Superlohkon sisältö}
Superlohko sisältää muunmuassa seuraavanlaisia arvoja tiedostojärjestelmästä, enkoodattuna 32-bittisinä little-endian-kokonaislukuina:
\begin{itemize}
    \item Tiedostojärjestelmän lohkon (block) koko \texttt{s\_log\_block\_size}. Yleisesti käytettyjä lohkon kokoja on 1, 2, ja 4 kilotavua.
          Mahdollisia tiedostojärjestelmän lohkokokoja rajoittaa se, että lohkon koon täytyy olla käytettävän levyn sektorin koon moninkerta.
          Yleisimmät käytetyt sektorin koot nykypäivänä ovat 512 ja 4096 tavua.
          Myöskin Linuxin ext2-ajurilla on lisärajoituksena että lohkon koko ei saa ylittää prosessoriarkkitehtuurin sivun kokoa,
          mikä yleisemmin (muun muassa Intelin x86-arkkitehtuurissa) on 4096 tavua.
    \item Ominaisuusbitit \texttt{s\_feature\_compat}, \texttt{s\_feature\_incompat} ja \texttt{s\_feature\_ro\_compat} jotka kertovat mitä laajennoksia tiedostojärjestelmässä on käytössä.
          Nämä ovat jaettu kolmeen eri luokkaan mikä mahdollistaa sekä taaksepäin- että eteenpäinyhteensopivuuden tietyissä rajoissa.
    \item Lohkoryhmien koot, erikseen datalohkoille ja inodeille.
          \texttt{s\_blocks\_per\_group} kertoo datalohkojen määrän yhdessä lohkoryhmässä ja \texttt{s\_inodes\_per\_group} inodejen lukumäärän yhdessä lohkoryhmässä.
    \item Vapaiden datalohkojen määrä \texttt{s\_free\_blocks\_count} ja datalohkojen kokonaismäärä \texttt{s\_blocks\_count}.
    \item Niinikään samat laskurit inodeille: \texttt{s\_free\_inodes\_count} kertoo vapaiden inodejen määrän ja \texttt{s\_inodes\_count} inodejen kokonaismäärän tiedostojärjestelmässä.
\end{itemize}

Ext2:ssa inodeille on varattu tila joka on erillinen datalohkoista.
Tiedostojärjestelmää luodessa valitut \texttt{s\_blocks\_per\_group}- ja \texttt{s\_inodes\_per\_group}-parametrit määräävät inodejen ja datalohkojen suhteellisen osuuden koko levytilasta.
Ext2:aa käyttäessä voikin joutua tilanteeseen, jossa käyttäjän näkökulmasta levytilaa (eli datalohkoja) on runsaasti vapaana, mutta kaikki inodet ovat käytössä, tai päinvastoin.

\subsection{Lohkoryhmäkuvaajien sisältö}
Kuten superlohkon kohdalla, lohkoryhmäkuvaajista säilytetään kopioita useassa kohtaa levyä.
Lohkoryhmäkuvaajat on yksinkertaisesti taulukko seuraavista tietorakenteesta:
\begin{itemize}
    \item \texttt{bg\_block\_bitmap} kertoo lohkon josta kyseisen lohkoryhmän lohkobittikartta alkaa.
          Bittikartan bitit kertovat mitkä lohkoryhmän datalohkoista ovat käytössä.
          Ykkösbitti tarkoittaa käytössä olevaa lohkoa ja nollabitti vapaata lohkoa.
    \item \texttt{bg\_inode\_bitmap} kertoo lohkon josta kyseisen lohkoryhmän inodebittikartta sijaitsee.
          Inodebittikartta kertoo mitkä kyseisen lohkoryhmän inodeista on käytössä.
          Samaan tapaan kuin lohkobittikartan kanssa, 1 tarkoittaa käytössä olevaa inodea ja 0 vapaata inodea.
    \item \texttt{bg\_free\_blocks\_count} ja \texttt{bg\_free\_inodes\_count} kertovat vapaiden lohkojen ja inodejen lukumäärän kyseisessä lohkoryhmässä.
          % Koska nämä kentät ovat vain 16-bittisiä, yhden lohkoryhmän 
    \item \texttt{bg\_inode\_table} kertoo mistä lohkosta kyseisen lohkoryhmän inodetaulu alkaa. Lohkoryhmän datalohkot sijaitsevat heti lohkoryhmän inodetaulun jälkeen.
\end{itemize}

\subsection{Inoden rakenne}

Ext2:ssa tietyn inoden paikannus inodenumeron perusteella on yksinkertaista.
Kuten edellä nähtiin, jokaisessa lohkoryhmässä on sama määrä inodeja ja lohkoryhmän sisällä inodet sijaitsevat yksinkertaisesti taulukossa.
Inodeiden numerointi alkaa ykkösestä, joten inoden numerosta voidaan laskea lohkoryhmän numero kaavalla:
$$ n_\text{bg} = \frac{n_\text{ino} - 1}{\texttt{s\_inodes\_per\_group}} $$

Kenttä \texttt{i\_blocks} viittaa lohkoihin jossa inoden data sijaitsee.
Kentän formaatti on 15-alkioinen taulukko 32-bittisiä kokonaislukuja jonka sisältö tulkitaan seuraavasti:
\begin{itemize}
    \item Taulukon ensimmäiset 12 alkiota sisältävät lohkonumerot tiedoston ensimmäiselle 12 lohkolle (lohkot 0--11).
          Nämä ovat \emph{suoria lohkoja} (direct blocks).
    \item Taulukon seuraava (13.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{epäsuoraan lohkoon} (indirect block).
          Itse epäsuora lohko taas sisältää taulukon lohkonumeroita, jotka kertovat inoden seuraavat datalohkojen numerot.
          Esimerkiksi jos tiedostojärjestelmän lohkokoko on 4096, sisältää epäsuora lohko 1024 lohkonumeroa,
          jolloin lohkot 12 -- 1035 löytyvät ensimmäisen epäsuoran lohkon kautta.
    \item Taulukon seuraava (14.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{toisen tason epäsuoraan lohkoon} (doubly indirect block).

    \item Taulukon seuraava (15.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{kolmannen tason epäsuoraan lohkoon} (triply indirect block).
\end{itemize}

\begin{figure}
    \label{ext2_inode_format}
    \includegraphics[width=1.0\textwidth]{gfx/ext2-blocks.pdf}
    \caption{Ext2:n rakenne levyllä.}
\end{figure}

\subsection{Hakemiston rakenne}
Ext2:n hakemisto koostuu \emph{hakemistoalkioista} (directory entry) jotka sijaitsevat inoden datalohkoissa.
Hakemistoalkion koko on vaihtelevanmittainen riippuen hakemistoalkion sisältämän tiedostonimen pituudesta.
Hakemistoalkio sijaitsee aina kokonaan yhden datalohkon sisällä.
Hakemistoalkio koostuu vakiokokoisesta otsakkeesta jota välittömästi seuraa tiedostonimi.
Otsakkeen rakenne on seuraavanlainen:

\begin{verbatim}
	uint32_t inode;
	uint16_t rec_len;
	uint8_t name_len;
	uint8_t file_type;
\end{verbatim}

Kenttä \texttt{inode} sisältää hakemistoalkion viittavan inoden numeron.
Mikäli inoden numero on nolla, on kyseinen hakemisto
Otsakkeen kenttä \texttt{name\_len} kertoo tiedostonimen pituuden.
Koska kentän koko on 8 bittiä, rajoittuu tiedostonimen maksimipituudeksi 255.
Kenttä \texttt{rec\_len} kertoo koko hakemistoalkion koon,
jonka perusteella voidaan paikantaa hakemiston seuraava hakemistoalkio.
joka voi olla suurempi kuin otsakkeen koko ja tiedostonimen pituus.

ext2:ssa siis hakemistoalkion paikantaminen tiedostonimen perusteella on aikavaativuudeltaan $O(n)$,
mikä tarkoittaa heikkoa suorituskykyä hakemiston koon kasvaessa.
Yksi ext2:n välittömän seuraajan, ext3:n tuomista uudistuksista on hajautukseen pohjautuva hakemistorakenne.

\subsection{Esimerkki hakemistosta}
Tarkastellaan hakemiston rakennetta luotaessa 1024 tavun lohkokokoa käyttävän tiedostojärjestelmän juureen alihakemisto \texttt{dir} ja sinne tyhjät tiedostot \texttt{abc}, \texttt{defghijklmn} ja \texttt{opqrstuvwxyz}.
Linux-ajurin luoma rakenne on seuraavanlainen:

\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    12 & 12  & 1  & "."            sekä 3 0-tavua. \\
    2  & 12  & 2  & ".."           sekä 2 0-tavua. \\
    13 & 12  & 3  & "abc"          sekä 1 0-tavu. \\
    14 & 20  & 11 & "defghijklmn"  sekä 1 0-tavu. \\
    15 & 968 & 12 & "opqrstuvwxyz" sekä loput lohkosta ovat 0-tavuja. \\
\end{tabular}

Nyt poistettaessa tiedosto \texttt{defghijklmn} muuttuu kolmannen hakemistoalkion (nimen \texttt{abc}) sisällöksi:
\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    13 & 20  & 3  & "abc"\\
\end{tabular}

Siis poistettavaa hakemistoalkiota edeltävän hakemistoalkion \texttt{rec\_len}-kenttää kasvatetään ``hyppäämään'' poistetun alkion yli.

\section{ext2 kaatumistilanteissa}

Edellisessä luvussa käytiin lävitse ext2:n tärkeimpiä levyllä sijaitsevia tietorakenteita.
Tarkastellaan nyt miten POSIX-tiedostojärjestelmäoperaatiot vaikuttavat ext2:n levyrakenteeseen.

\subsection{Tiedoston luominen}
Tarkastellaan Linuxin ext2-ajurin tekemiä levykirjoituksia luotaessa tyhjän ext2-tiedostojärjestelmän juurihakemistoon uusi tyhjä tiedosto komennolla \texttt{touch new}.
Havaittiin seuraavat operaatiot:

\begin{enumerate}
    \item{Juurihakemistoon luodaan uusi hakemistoalkio nimelle \texttt{new} osoittamaan inodeen 13.}
    \item{Inode 13 merkitään varatuksi inodebittikarttaan.}
    \item{Juurihakemiston inoden aikaleimaa (\texttt{i\_mtime}) päivitetään.}
    \item{Inoden rakenne inodetaulussa täytetään.}
    \item{Superlohkon vapaiden inodejen määrää vähennetään yhdellä.}
    \item{Lohkoryhmän 0 vapaiden inodejen määrää vähennetään yhdellä.}
\end{enumerate}

Yhteensä siis koko operaation suorittamiseen vaaditaan kuusi levykirjoitusta viiteen eri tietorakenteeseen levyllä.
Nyt kaatumistilanteessa tämän operaation aikana voi olla seuraavia vaikutuksia.
Mikäli kaatuminen tapahtuu levykirjoitusten 4--5 tai 5--6 välissä,
ovat vain vapaiden inodejen laskurit epäkonsistentteja itse levyn kanssa.
Tällä ei sinänsä pitäisi olla muuta merkitystä tiedostojärjestelmälle kuin että käyttäjä näkee vapaiden inodejen määrän (komennolla \texttt{df -i}) väärin.
Sen sijaan kaatuminen kirjoitusten 1--2, 2--3 tai 3--4 välillä johtaa hakemistoalkioon mikä osoittaa alustamattomaan inodeen.
Lisäksi kaatuminen kirjoitusten 1--2 välissä johtaa edellisten ongelmien lisäksi uuteen ongelmatilanteeseen jossa hakemistoalkio viittaa inodeen jota ei ole varattu inodebittikartassa.

\subsection{Tiedostojärjestelmän tarkistusohjelma \emph{fsck}}

Tiedostojärjestelmän mukana jaellaan tyypillisesti \emph{fsck (file system check)}-niminen tarkastusohjelma joka pyrkii tarkistamaan tiedostojärjestelmän metadatan oikeellisuuden ja tarvittaessa korjaamaan kohdattuja ongelmia.
Ext2:n mukana tuleekin \texttt{e2fsck}-niminen tarkistustyökalu jonka toimintaa kuvaillaan tässä luvussa.

\subsubsection{Toiminta}

Tyypillinen vaatimus tiedostojärjestelmän tarkistusohjelmilta on että niiden kuuluu toimia monentyyppisten korruptioiden kanssa.
Kaatumistilanteiden lisäksi korruptioita voi aiheutua tiedostojärjestelmäajurin ohjelmointivirheistä tai laitteiston aiheuttamista ongelmista.
Koska \texttt{e2fsck}:n täytyy käydä koko tiedostojärjestelmän metadata läpi,
pitää jo koko metadatan paikantamisessa olla varovainen,
koska johonkin muuhun metadataan viittaava kenttä itsessään voi olla korruptoitunut.
Myöskin metadataan tehtävät korjaukset on tärkeä tehdä tietyssä järjestyksessä.

\texttt{e2fsck} käy tiedostojärjestelmän läpi kuudessa vaiheessa:
\begin{enumerate}
    \item{Superlohko}
    \item{}
\end{enumerate}
\section{Yhteenveto}
