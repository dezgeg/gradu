\section{Johdanto}

Tiedostojärjestelmät ovat se pääasiallinen tapa jolla sekä käyttäjät että sovellukset voivat käsitellä tietokoneen massamuistia,
eli ylipäätänsä tallentaa tietoa siten että se säilyy tietokoneen virran katkaisemisen jälkeenkin.
Melkeinpä jokaiselle tietokoneen käyttäjälle tuleekin siis tutuksi käyttöjärjestelmän tarjoamat mahdollisuudet tiedostojen käsittelyyn,
kuten tiedostojen tallentamiseen kiintolevylle, niiden poistamiseen tai kopioimiseen esimerkiksi USB-tikulle.
Sekä käyttäjän että sovelluskehittäjän näkökulmasta tiedostojärjestelmän sisäinen toiminta on abstraktoitu verrattaen hyvin.
Riippumatta siitä onko käyttäjä avaamassa dokumenttia tekstinkäsittelyohjelmalla useiden teratavujen kokoiselta mekaaniselta kiintolevyltä taikka muutaman gigatavun flash-muistitikulta,
on käyttäjäkokemus samanlainen ja tekstinkäsittelyohjelma käyttää täsmälleen samoja käyttöjärjestelmän rajapintoja tiedostojen käsittelyyn.
Moderneissa käyttöjärjestelmissä on sovellusten käyttämät rajapinnat tiedostojen käsittelyyn eroteltu itse tiedostojärjestelmästä~\cite{UnixFsBook}.
% UnixFsBook: page 6, FSS, SVR3, 1987.
Tämä mahdollistaa sen, että käyttöjärjestelmä voi tukea useita tiedostojärjestelmiä samaan aikaan,
jolloin samaan tietokoneeseen voi olla samaan aikaan liitettynä monentyyppisiä tiedostojärjestelmiä joko eri tallennusmedioilla tai saman levyn eri osioilla.
Uusia tiedostojärjestelmiä kehitetäänkin jatkuvasti muun muassa parantamaan suorituskykyä tai tuomaan uusia ominaisuuksia.
Esimerkiksi Microsoft on vuosien saatossa vaihtanut Windows-käyttöjärjestelmän oletustiedostojärjestelmän FAT:sta NTFS:ään~\cite{BefsBook},
% BefsBook: page 40
ja kuten tämän tutkielman myöhemmissä luvuissa nähdään,
on Linux-maailmassa ollut reilustikin valinnanvaraa erityyppisissä tiedostojärjestelmissä.

Eräs motivaattori uusien tiedostojärjestelmien kehittämiseen on luotettavuuden parantaminen.
Useat aikanaan käytetyt tiedostojärjestelmät,
kuten DOS-käyttöjärjestelmän FAT tai alkuperäisen Unixin tiedostojärjestelmä,
olivat nykymittapuulla erittäin yksinkertaisia eivätkä antaneet juuri mitään takuuta sille että tiedostojärjestelmän eheys säilyisi \emph{kaatumistilanteissa}.
Tyypillisiä tiedostojärjestelmän kaatumistilanteita ovat esimerkisi koko tietokoneen sammuminen virtakatkoksen takia tai
tilanteita jossa järjestelmä pitää käynnistää uudelleen sammuttamatta sitä turvallisesti,
esimerkiksi jonkin vakavan käyttöjärjestelmävirheen takia.
Kyseisillä tiedostojärjestelmillä kaatumistilannetta seurasikin aina koko tiedostojärjestelmän tarkistus \texttt{fsck}-ohjelmalla,
joka kävi koko levyn läpi ja yritti parhaansa mukaan palauttaa tiedostojärjestelmän toimivaan tilaan~\cite{Ext2Journal}.
Fsck-ohjelman suorituksen aikana tiedostojärjestelmä ei ole normaalisti käytettävissä,
mikä tiedostojärjestelmän käyttötarkoituksesta riippuen tarkoittikin mahdollista käyttökatkosta koko järjestelmälle.
Modernimmat tiedostojärjestelmät, kuten Linuxin ext3 vuodelta 2001, ovatkin suunniteltu selviämään kaatumistilanteista nopeasti ja turvallisesti,
joten tämänkaltaiset pitkät käyttökatkot tiedostojärjestelmätarkistusten takia ovat olleet historiaa jo tovin.

Itse tiedostojärjestelmä siis vaikuttaa merkittävästi siihen mitä seurauksia järjestelmän kaatumistilanteesta johtaa, mutta ongelma on monitahoinen.
Vastuu siitä että käyttäjän dataa ei korruptoidu tiedostojärjestelmän kaatumistilanteessa ei ole pelkästään tiedostojärjestelmä-ajurin tai käyttöjärjestelmän taholla,
vaan myös sovelluksilla.
Tämän tutkielman tavoitteena on esitellä kyseisiä menetelmiä tiedostojärjestelmän eheyden säilyttämiseen kaatumistilanteissa.
% FIXME: motivaatio etc.

\section{Unix-tiedostojärjestelmien perusteet}

Vaikka tiedostojärjestelmät konseptina ovatkin todennäköisesti tuttuja monille tietokoneenkäyttäjille,
on laitettava merkille ettei tiedostojärjestelmälle ole olemassa mitään yhtä oikeaa määritelmää
vaan eri käyttöjärjestelmissä ne toimivat hieman eri tavoilla.
Koska tässä tutkielmassa tarkastellaan pääosin Unix-tyyppisten käyttöjärjestelmien tiedostojärjestelmiä,
tutustutaan ensin niiden periaatteisiin läheisemmin.
Nykypäivän Unix-tyyppisten käyttöjärjestelmien tiedostojärjestelmärajapintoja yhdistää pääosin \emph{POSIX (Portable Operating System Interface for uniX)}-standardi~\cite{PosixSpec}.
% FIXME: jatka tätä ihan vähäsen

\subsection{Unixin ja POSIX-standardin lyhyt historia}

Unix-käyttöjärjestelmän kehitys alkoi 60-luvun lopulla AT\&T:n Bell Labs-kehityslaboratoriassa.
Ken Thompson ja Dennis Ritchie olivat olleet kehittämässa MULTICS-nimistä interaktiivista usean käyttäjän moniajokäyttöjärjestelmää yhdessä General Electricin ja MIT:n yliopiston kanssa.
MULTICS-projektin tavoitteet olivat aikaansa nähden kunnianhimoisia ja käyttöjärjestelmän valmistuminen näyttikin venyvän ja venyvän, joten Bell Labs vetäytyi lopulta pois projektista.
Thompson ja Ritchie eivät olleet tyytyväisiä tilanteeseen vaan alkoivat kehittää omaa MULTICSin insipiroimaa PDP-7-tietokoneelle~\cite{UnixFsBook}.
Unixia suunniteltiin ja käytettiin aluksi vain AT\&T:n sisäiseen käyttöön,
kuten tekstidokumenttien käsittelyyn sekä latomiseen,
kunnes vuonna 1974 Unix tuotiin akateemisen maailman tietoisuuteen Thompsonin ja Ritchien julkaisemalla artikkelilla ``The UNIX time-sharing system''~\cite{UnixPaper}
% TODO tell what it supports and when it was rewritten to C
Tämän seurauksena ulkopuolisetkin kiinnostuivat Unixista.
Bell Labsin emoyhtiöllä oli kuitenkin tuohon aikoihin monopoliasema Yhdysvaltojen puhelinverkkotoimintoihin,
joten kilpailuviraston kanssa tehdyn sopimuksen pohjalta sen oli kiellettyä alkaa tekemään liiketoimintaa muilla toimialueilla eikä voinut siten tuotteistaa Unixia.
Sen sijaan Unixin lähdekoodia alettiin lisensoida nimellistä kertakorvausta vastaan pääasiassa yliopistoille mutta myös joillekin yrityksille,
jotka alkoivat tehdä omia muutoksiaan Unixiin ja jaella tai markkinoida niitä.
Tunnetuin akateemisen maailman tuottama Unix-johdannainen on Berkeleyn yliopistoston tuottama BSD (Berkeley Software Distribution); 1BSD 1977 ja 3BSD 1979.
Esimerkiksi Berkeleyn yliopiston kehittämä BSD, Microsoftin Xenix sekä Sun Microsystemsin SunOS. %XXX
AT\&T:n puhelinverkkotoiminnan monopoliaseman purkaantuminen avasi yhtiölle tilaisuuden myydä Unixia kaupallisesti,
joka julkaistiin Unix System V-nimellä vuonna 1983.
Markkinoilla oli siis saatavilla useita periaatteessa Unix-pohjaisia käyttöjärjestelmiä mutta jotka kaikki käytännössä toimivat hieman eri tavalla.
Sovellusohjelmoijan kannalta tämä hankaloitti huomattavasti monella eri Unix-järjestelmällä toivivien ohjelmien toteutusta.
Tämän ratkaisemiseksi kehiteltiin POSIX-standardi~\cite{PosixSpec} yhtenäistämään eri Unix-toteutusten tarjoamat sovellusrajapinnat.
Ensimmäinen versio standardista julkaistiin vuonna 1988.
POSIX-standardi määrittelee muun muassa komentorivityökaluja sekä C-kielisiä rajapintoja muun muassa tiedostojen, säikeiden ja prosessien hallintaan.
Käytännössä mitään Linux-jakelua ei virallisesti ole sertifioitu POSIX-yhteensopivaksi (lähde?),
mutta käytännössä kehittäjät tähtäävät POSIX-yhteensopivuuteen~\cite{LinuxKernelBook}.

Tiedostojärjestelmien käsittelyä varten POSIX tarjoaa sekä komentorivikomentoja kuten \texttt{ls}, \texttt{cp}, \texttt{rm} pääasiassa käyttäjien käyttöön että ohjelmointirajapintoja C-ohjelmointikielellä sovellusten toteuttamista varten.
Valtaosa näistä ohjelmointirajapinnoista toimivat varsin matalalla tasolla,
joista sovellusohjelmoijan täytyy itse koostaa useat vähänkään monimutkaisemmat tiedostojärjestelmä-operaatiot.
Erityisesti tiedostojärjestelmän käyttö kaatumisturvallisesti vaatii ohjelmoijalta erityistä kykyä ja ymmärrystä käyttää POSIX-rajapintoja oikein,
mitä käsitellään myöhemmin kappaleessa~\ref{ChapPosixDataConsistency}.
Tästä syystä esitelläänkin seuraavaksi lyhyesti tärkeimmät POSIXin tarjoamat C-rajapinnat tiedostojen käsittelyyn.

\subsection{POSIX-tiedostojärjestelmän perusteet}
POSIX-tiedostojärjestelmä on \emph{hierarkkinen tiedostojärjestelmä},
eli tavallisten tiedostojen lisäksi tiedostojärjestelmä tukee \emph{hakemistoja},
jotka voivat sisältää mielivaltaisen määrän tiedostoja tai hakemistoja.
Tiedostojärjestelmä muodostaa siis puurakenteen, mistä tulee tämä hierarkkisen määritelmä.
Kaikilla tiedostoilla ja hakemistoilla on jokin epätyhjä käyttäjän antama nimi,
jonka täytyy olla uniikki siinä hakemistossa jossa kyseinen tiedosto tai hakemisto sijaitsee.
Mikä tahansa tiedosto tai hakemisto Unix-tiedostojärjestelmässä voidaan siis paikantaa \emph{tiedostopolulla},
eli merkkijonolla jossa \texttt{/}-merkillä on eroteltuna alihakemistojen nimet joita pitkin pitää kulkea tiedoston paikantaakseen.
Esimerkiksi tiedostopolku \texttt{/home/tuomas/gradu.tex}
tarkoittaa että juurihakemistosta \texttt{/} paikannetaan alihakemisto \texttt{home}, josta löytyy alihakemisto \texttt{tuomas}, jonka sisällä on viimein tiedosto \texttt{gradu.tex}.

% \texttt{/}-merkillä alkavat tiedostopolut ovat \emph{absoluuttisia} polkuja,
% muut polut ovat \emph{suhteellisia} polkuja.
% Jokaisella ajonaikaisella prosessilla on oma nykyinen hakemistonsa (current directory),
% jonka suhteen suhteelliset polut tulkitaan.
% Esimerkiksi prosessilla jonka nykyinen hakemisto on \texttt{/home/tuomas},
% viittaisi polku \texttt{Downloads/kuva.jpg} tiedostoon \texttt{/home/tuomas/Downloads/kuva.jpg}.

POSIXissa on kaksi erityistä `virtuaalista' tiedostonimeä, \texttt{.} ja \texttt{..}, joiden voidaan mieltää löytyvän jokaisesta hakemistosta.
Näistä \texttt{.} viittaa aina siihen hakemistoon jossa se sijaitsee ja \texttt{..} viittaa ylempään hakemistoon hakemistopuussa.
Siis esimerkiksi polku \texttt{/home/tuomas/.} viittaa samaan hakemistoon kuin polku \texttt{/home/tuomas}.
Lisäksi \texttt{.}-nimeä voi käyttää missä tahansa kohtaa polkua,
eli esimerkiksi \texttt{/home/./tuomas} tai \texttt{/home/././tuomas/././.} viittaavat edelleen samaan hakemistoon.
Nimi \texttt{..} taas viittaa ylempään tasoon hakemistorakenteessa,
eli tiedostopolku \texttt{/home/tuomas/..} viittaa samaan hakemistoon kuin tiedostopolku \texttt{/home}.
Juurihakemiston tapauksessa \texttt{..}-nimi vie takaisin juurihakemistoon itseensä, eli tiedostopolut \texttt{/..} ja \texttt{/} toimivat identtisesti.

Tiedostot voidaan jaotella kahtia tavallisiin tiedostoihin ja erityistiedostoihin.
Unixissa tavallisia tiedostoja voi käsitellä vain tavupohjaisina,
eli mikäli sovellus tarvitsee esimerkiksi tietuepohjaista tiedostonkäsittelyä jää sen toteutus sovelluksen vastuulle.
Erikoistiedostoja taas löytyy viittä eri tyyppiä.
Merkittävin näistä on \emph{symbolinen linkki} (\emph{symbolic link}).
TODO selitä...

Muita tuettuja tiedostotyyppejä ovat \emph{nimetty putki} (\emph{named pipe}) ja \emph{paikallinen pistoke} (\emph{domain socket}).
Kumpikaan näistä ei persistoi mitään dataa levylle,
vaan niitä käytetään Unix-sovellusohjelmoinnissa mekanismina \emph{prosessien väliseen kommunikointiin} (\emph{IPC}, \emph{Inter-Process Communication}).
Periaatteessa siis vastaava toiminnallisuus voitaisiin toteuttaa käyttöjärjestelmään täysin tiedostojärjestelmästä riippumattomasti,
mutta tämä Unixin tapa tuoda IPC-mekanismit ikään kun tiedostojärjestelmäobjekteiksi mahdollistaa niiden käsittelyn samoilla työkaluilla ja rajapinnoilla kuin tavallisia tiedostoja.
Esimerkiksi myöhemmin esiteltävät tiedostojen käyttöoikeudet toimivat nimetyille putkille ja paikallisille pistokkeille samalla tavalla kuin ne toimivat tavallisille tiedostoille ja hakemistoille.

\subsection{Tiedoston avaus ja sulkeminen}
Tiedoston avaus tapahtuu \texttt{open}-funktiolla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html#tag_16_357
\begin{verbatim}
int open(const char *path, int oflag, ...);
\end{verbatim}

Parametri \texttt{path} on tiedoston polku merkkijonona
ja \texttt{oflag} on kasa lippuja jotka määräävät miten tiedosto avataan.
Yksi lipuista \texttt{O\_RDONLY}, \texttt{O\_WRONLY} ja \texttt{O\_RDWR} on pakko antaa.
Ne määräävät avataanko tiedosto vain lukua, vain kirjoitusta tai sekä lukua että
kirjoitusta varten.
Muita mahdollisia lippuja on esimerkiksi \texttt{O\_TRUNC},
joka tyhjentään tiedoston sisällön (truncate).
Tiedoston voi myös luoda antamalla lipun \texttt{O\_CREAT},
jolloin kolmas parametri määrittelee luodun tiedoston oikeudet.
Funktio palauttaa onnistuessaan \texttt{int}-tyyppisen \emph{tiedostokahvan},
joka viittaa kyseiseen avattuun tiedostoon.
Tiedostokahvat ovat prosessikohtaisia,
eli yrittämällä lukea samalla tiedostokahvan numeerisella arvolla
jossakin toisessa prosessissa tapahtuu jotain odottomatonta.

Tiedoston sulkeminen tapahtuu \texttt{close}-funktiolla,
jolle annetaan auki oleva tiedostokahva ainoana parametrina:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html#tag_16_67
\begin{verbatim}
int close(int fildes);
\end{verbatim}

\subsection{Tiedoston luku ja kirjoitus}

Tiedostosta luku ja tiedostoon kirjoitus tapahtuu ohjelmoijan näkökulmasta suhteellisen
samalla tavalla, funktioilla \texttt{read} ja \texttt{write}:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html#tag_16_474
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html#tag_16_685
\begin{verbatim}
ssize_t read(int fildes, void *buf, size_t nbyte);
ssize_t write(int fildes, const void *buf, size_t nbyte);
\end{verbatim}

Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
\texttt{buf} on osoitin \texttt{nbyte} tavun kokoiseen puskuriin johon
luetaan tai josta kirjoitetaan.
Onnistuessaan funktiot palauttavat kuinka monta tavua luettiin tai kirjoitettiin.
Paluuarvo voi siis olla pienempi kuin mitä ohjelma pyysi lukemaan tai kirjoittamaan,
esimerkiksi jos kirjoittaessa levy täyttyi kesken tai luettaessa
tiedosto loppui kesken.

Jokaisella tavalliseen tiedostoon viittaavalla tiedostokahvalla on
sijainti tavuina missä kohtaa tiedostoa ollaan ja josta
lukeminen tai kirjoittaminen aloitetaan.
Onnistuessaan sijainti tiedostossa siirtyy eteenpäin paluuarvon verran.
Huomattavaa on, että tiedostosta voi lukea ja kirjoittaa tavun tarkkuudella,
vaikka taustalla oleva media tukisi vain esimerkiksi 512 tavun kokoisen sektorin lukemista tai kirjoittamista.
Tämä on yksi tapa jolla tiedostojärjestelmä abstraktoi laitteistoa.

Tiedostokahvan sijainnin voi selvittää ja sijaintia tiedostossa voi
siirtää \texttt{lseek}-kutsulla:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html#tag_16_310
\begin{verbatim}
off_t lseek(int fildes, off_t offset, int whence);
\end{verbatim}

Ensimmäinen parametri \texttt{fildes} on tiedostokahva jota operoidaan.
Kolmas parametri \texttt{whence} kertoo miten \texttt{offset}-parametri tulkitaan:

\begin{itemize}
    \item Arvo \texttt{SEEK\_SET} asettaa kahvan sijainniksi \texttt{offset}.
    \item Arvo \texttt{SEEK\_CUR} siirtää kahvaa eteenpäin \texttt{offset} tavua.
    \item Arvo \texttt{SEEK\_END} siirtää kahvan \texttt{offset} tavua eteenpäin laskien tiedoston lopusta.
\end{itemize}

Onnistuessaan kutsu palauttaa sijainnin johon siirryttiin.
Sijainnin voi siis selvittää siirtymättä tiedostossa kutsulla \texttt{lseek(fd, , SEEK\_CUR)}.

Itse sisällön lisäksi jokaisella tiedostolla on metadataa,
joka kertoo muun muassa tiedoston omistajan tai aikaleiman jolloin tiedostoa on viimeksi muokattu.
Metadataa voi lukea \texttt{fstat()}- tai \texttt{stat()}-funktioilla:
% FIXME jatka

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html#tag_16_173
\begin{verbatim}
int fstat(int fildes, struct stat *buf);
\end{verbatim}

% dev_t st_dev            Device ID of device containing file
% ino_t st_ino            File serial number.
% mode_t st_mode          Mode of file (see below).
% nlink_t st_nlink        Number of hard links to the file.
% uid_t st_uid            User ID of file.
% gid_t st_gid            Group ID of file.
% dev_t st_rdev           Device ID (if file is character or block special).
% off_t st_size           For regular files, the file size in bytes.
%                         For symbolic links, the length in bytes of the
%                         pathname contained in the symbolic link.
% struct timespec st_atim Last data access timestamp.
% struct timespec st_mtim Last data modification timestamp.
% struct timespec st_ctim Last file status change timestamp.
% blksize_t st_blksize    A file system-specific preferred I/O block size
%                         for this object. In some file system types, this
%                         may vary from file to file.
% blkcnt_t st_blocks      Number of blocks allocated for this object.
%

Tiedoston (mutta ei hakemistoa) voi poistaa \texttt{unlink()}-funktiolla:
\begin{verbatim}
int unlink(const char *path);
\end{verbatim}

Hakemiston poistamisille on oma funktio \texttt{rmdir()}:

\begin{verbatim}
int rmdir(const char *path);
\end{verbatim}
Hakemiston poistaminen onnistuu vain mikäli hakemisto on tyhjä.

%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html#tag_16_635
Tiedoston tai hakemiston voi uudelleennimetä \texttt{rename()}-funktiolla:
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html#tag_16_487
\begin{verbatim}
int rename(const char *old, const char *new);
\end{verbatim}

Uudelleennimeämisen ei tarvitse tapahtua saman hakemiston sisällä,
vaan esimerkiksi \texttt{rename("/tmp/file.tmp", "/home/foo/file.txt")} on sallittua,
mutta sekä lähde- että kohdepolun täytyy sijaita samalla tiedostojärjestelmällä.
Kohdepolku voi viitata myös olemassaolevaan tiedostoon,
jolloin kyseinen olemassaoleva tiedosto poistetaan operaation yhteydessä ikään kuin \texttt{unlink()}-kutsua olisi käytetty ennen uudelleennimeämistä.
Kaikissa tapauksissa operaatio on atominen.

%%% % FIXME: hard links
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/chmod.html#tag_16_58
%%% \begin{verbatim}
%%% int chmod(const char *path, mode_t mode);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html#tag_16_59
%%% \begin{verbatim}
%%% int chown(const char *path, uid_t owner, gid_t group);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html#tag_16_293
%%% \begin{verbatim}
%%% int link(const char *path1, const char *path2);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html#tag_16_635
%%% \begin{verbatim}
%%% int unlink(const char *path);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html#tag_16_475
%%% \begin{verbatim}
%%% struct dirent *readdir(DIR *dirp);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html#tag_16_476
%%% \begin{verbatim}
%%% ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html
%%% \begin{verbatim}
%%% int ftruncate(int fildes, off_t length);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdopendir.html#tag_16_127
%%% \begin{verbatim}
%%% DIR *opendir(const char *dirname);
%%% \end{verbatim}
%%%
%%% % http://pubs.opengroup.org/onlinepubs/9699919799/functions/closedir.html
%%% \begin{verbatim}
%%% int closedir(DIR *dirp);
%%% \end{verbatim}

\section{POSIX kaatumistilanteessa}
\label{ChapPosixDataConsistency}
Tietokoneiden massamuistit ovat tyypillisesti keskusmuistia merkittävästi hitaampia lukea ja kirjoittaa.
Tyypillinen tapa parantaa tiedostojärjestelmän suorituskykyä onkin käyttää osaa keskusmuistista välimuistina tiedostojärjestelmälle.
POSIX-standardi antaakin tiedostojärjestelmätoteutuksille merkittäviä vapauksia erilaisten välimuistien käyttöön,
joita muun muassa Linux hyödyntää merkittävissä määrin.
Kyseisenkaltaisilla optimoinneilla on kuitenkin varjopuolensa,
sillä ne hankaloittavat kaatumistilanteita kestävien sovellusten, kuten tietokantajärjestelmien toteuttamista.
Tässä luvussa tarkastellaankin POSIXin tarjoamia rajapintoja tiedostojärjestelmän välimuistien hallintaan sekä muita sovellusohjelmoijan kannalta huomioonotettavia seikkoja.

Erinäiset levyvälimuistit olivat käytössä jo hyvin varhain Unixissa.
Jo Ritchien ja Thompsonin alkuperäisestä ``The UNIX time-sharing system''-artikkelista vuodelta 1974 löytyy lyhyt selostus Unixin \emph{lohkovälimuistista} (\emph{buffer cache}).
Tämänkaltainen pelkkiä levylukuja säilyttävä välimuisti ei näy sovellusohjelmoijalle mitenkään. % XXX
Tästä looginen seuraus on kirjoitusten vieminen välimuistiin.
Tämä voidaan tehdä sekä tiedoston metadatalle että varsinaiselle datalle.
Siis sekä datan kirjoitus \texttt{write()}-funktiolla että
tiedoston metadataa muokkaavat operaatiot,
mukaanlukien aikaleimojen päivitykset eivät välttämättä päädy levylle asti tiedostojärjestelmäkutsun palatessa.
Levyvälimuistin hallintaan löytyy POSIXissa kaksi keskeistä funktiota~\cite{PosixSpec}:

% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html
% http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html
\begin{verbatim}
int fsync(int fildes);
int fdatasync(int fildes);
\end{verbatim}

Operaatio \texttt{fdatasync()} pakottaa parametrina annettua tiedostokahvaa \texttt{fildes} vastaavan tiedoston levyvälimuistin kirjoittamisen.
Funktiokutsu ei palaa kunnes data on turvallisesti kirjoitettu levylle.
\texttt{fdatasync()}-kutsu ei vaikuta tiedoston metadataan muuten kuin että kutsun onnistuessa taataan että tiedostoon tähän asti tehdyt kirjoitukset ovat luettavissa kaatumisen jälkeenkin.
Käytännössä käyttäjän näkokulmasta tämä takaa vain että tiedoston koko on ajan tasalla.
Funktio \texttt{fsync()} on vahvempi versio \texttt{fdatasync()}:stä joka lisäksi pakottaa kaiken tiedoston viittaavan inoden metadatan kirjoitettavan levylle.
Lisäksi on varmistettava erikseen että tiedoston inodeen viittaavat tiedostonimet ovat kirjoitettu pysyvästi levylle.
Tämä tapahtuu kutsumalla \texttt{fsync()}-funktiota hakemistolle jossa tiedostonimi sijaitsee.

\subsection{Esimerkki tekstieditorista}
Tarkastellaan nyt esimerkin avulla miten POSIXin levyvälimuistin käsittelyfunktioilla voidaan toteuttaa kaatumisturvallisia sovelluksia.
Melkeinpä yksinkertaisin mahdollinen sovellus jossa kaatumisturvallisuus on tärkeää on perus tekstieditori.
Tyypillinen käyttötapaus on, että käyttäjä avaa editorissa tiedoston, muokkaa sitä, ja tallentaa muokatun sisällön samalla nimellä alkuperäisen tiedoston päälle.
Suoraviivaisesti toteutettuna tämä menetelmä näyttää seuraavalta:

\begin{verbatim}
int fd = open("/mnt/usb/file.txt", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
close(fd);
\end{verbatim}

Tämä sekvenssi operaatioita ei kuitenkaan ole turvallinen vaikka edes tiedostojärjestelmän kaatumista ei tapahtuisi.
Jo pelkkä tekstieditorin kaatuminen \texttt{open()}- ja \texttt{write()}- kutsujen välissä jättää jäljelleen tyhjän tiedoston.
Yksinkertainen yritys välttyä tältä ongelmalta on ensin kirjoittaa tallennettava sisältö väliaikaistiedostoon,
ja hyödyntää \texttt{rename()}-kutsun kykyä atomisesti korvata tiedosto toisella:

\begin{verbatim}
int fd = open("/mnt/usb/file.txt.tmp", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
close(fd);
rename("/mnt/usb/file.txt.tmp", "/mnt/usb/file.txt");
\end{verbatim}

Tämä versio sietää sovelluksen kaatumisen mutta ei toimi tiedostojärjestelmän kaatumistilanteessa,
sillä mikään ei takaa että \texttt{write()}-kutsun tekemät kirjoitukset ja tiedoston uudelleennimeäminen \texttt{rename()}-kutsulla kirjoitettaisiin levylle edellä mainitussa järjestyksessä.
Tiedostojärjestelmän kaatumistilanteessa tyhjä tai osittain kirjoitettu tiedosto on siis edelleen mahdollinen.
Sen sijaan täysin kaatumisturvallinen tallennus on toteutettu Gedit-tekstieditorissa seuraavasti~\cite{OptimisticCrashConsistency}:

\begin{verbatim}
int fd = open("/mnt/usb/file.txt.tmp", O_CREAT | O_WRONLY | O_TRUNC);
write(fd, uusi_sisalto, strlen(uusi_sisalto));
fsync(fd);
close(fd);
rename("/mnt/usb/file.txt.tmp", "/mnt/usb/file.txt");
int dfd = open("/mnt/usb", O_DIRECTORY | O_RDONLY);
fsync(dfd);
close(dfd);
\end{verbatim}

\texttt{write()}-ja \texttt{rename()}-kutsujen väliin on siis lisätty yksi \texttt{fsync()}-kutsu takaamaan että näiden operaatioiden järjestys ei vaihdu levylle kirjoittaessa.
Tämä lisätty \texttt{fsync(fd)} tekee tiedoston tallennusoperaatiosta atomisen mutta ei vielä takaa pysyvyyttä.
Pysyvyyteen vaaditaan \texttt{fsync()}-operaation suoritus kohdetiedoston sisältävälle hakemistolle,
mikä takaa että \texttt{rename()} kutsun tekemän muutokset itse hakemiston sisällölle ovat päätyneet levylle.

Kuten tästä esimerkistä nähtiin, on yksinkertaisenkin koostetun operaation toteuttaminen kaatumisturvallisesti verrattaen haastavaa,
mikäli kaikki POSIXin tarjomat vapaudet tiedostojärjestelmille otetaan huomioon.
POSIX kuitenkin on pelkkä abstrakti spesifikaatio, joten herääkin kysymys millaisia ongelmia käytännössä syntyy.
Aihetta on mahdollista tutkia kokeellisesti kahdelta kannalta -- sekä tiedostojärjestelmien että sovellusten näkökulmasta.
Tiedostojärjestelmien kannalta mielenkiintoinen kysymys on esimerkiksi operaatioiden kirjoitus levylle eri järjestyksessä kuin mitä sovellus ne teki --
tapahtuuko sitä ylipäätään vaiko esimerkiksi vain tiettyjä tiedostojärjestelmäkutsuja tehdessä sopivassa järjestyksessä.
Toisaalta taas sama kysymys toistuu sovellustenkin kanssa, eli käyttävätkö sovellukset varmasti tiedostojärjestelmäfunktioita oikein siten
että kaatumisturvallisuus säilyy millä tahansa POSIX-yhteensopivalla tiedostojärjestelmällä.
Molempia näistä aiheista on tutkittu kokeellisesti artikkelissa ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''~\cite{PosixDataConsistency} vuodelta 2014,
joten tarkastellaan aiheita seuraavissa aliluvuissa.

\subsection{Tiedostojärjestelmän persistenssiominaisuudet}
Kuten edellä nähtiin, POSIXin konsistenssimalli tarjoaa tiedostojärjestelmätoteutuksille vapauksia suorituskyvyn parantamiseen
mutta jotka samalla tuottavat haasteita sovellusohjelmoijille mikäli tavoitteena on käyttää tiedostojärjestelmää kaatumisturvallisesti.
Ensimmäinen osuus ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''-artikkelin tutkimuksesta
selvittääkin kokeellisesti millaisia \emph{persistenssiominaisuuksia} eri Linux-tiedostojärjestelmillä on~\cite{PosixDataConsistency}.

Tiedostojärjestelmien osalta testattiin kuutta Linux-tiedostojärjestelmää: \texttt{btrfs}, \texttt{ext2}, \texttt{ext3}, \texttt{ext4}, \texttt{reiserfs} sekä \texttt{xfs}.
Lisäksi tiedostojärjestemiä kokeiltiin eri tiedostojärjestelmäkohtaisilla optioilla,
tuottaen yhteensä 16 konfiguraatiota.
Persistenssiominaisuuksien testaus tapahtuu tutkijaryhmän kehittämällä BOB:ksi (\emph{Block order breaker}) kutsutulla työkalulla.
Sen periaatteena on nauhoittaa testattavan tiedostojärjestelmän tekemiä levykirjoituksia lokitiedostoon,
jonka avulla voidaan jälkikäteen käydä kaikki mahdolliset levyn tilat (joista siis jokainen vastaa mahdollista kaatumistilannetta) läpi.
Nyt kaatumistilanteista voidaan etsiä vastaesimerkkejä joissa testattava persistenssiominaisuus ei päde.
BOB:n voidaan siis vain todeta jonkin persistenssiominaisuuden paikkaansapitämättömyys, mutta ei toisinpäin.

% TODO for next release
% Ensimmäisiä testattuja persistenssiominaisuuksia on erinäisten operaatioiden atomisuus.
% Jo varsin yksinkertainen operaatio, tiedoston loppuun kirjoittaminen tuottaa erilaisia tuloksia eri tiedostojärjestelmäkonfiguraatioilla
% sekä myös kirjoitettavan datan määrä vaikuttaa tulokseen.
% Jo yhden sektorin (tai vähemmän) lisääminen tiedostoon ei ole atominen operaatio muutamalla tiedostojärjestelmällä: ext2 sekä
% ext3, ext4 ja reiserfs mikäli käytetään writeback-journalointitilaa.

\section{Sovellusten käyttäytyminen kaatumistilanteessa}

Toinen ``All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-consistent Applications''-artikkelin tutkima aihe on erinäisten Linux-sovellusten ja tietokantojen käyttäytyminen kaatumistilanteessa.
Aiemmin kappaleen alussa nähtiin miten tekstieditorin tiedoston tallennuksesta saatiin tehtyä kaatumisturvallinen POSIX-tiedostojärjestelmäoperaatioita koostamalla.
Tässä kyseisessä käyttötapauksessa päästiin haluttuun lopputulokseen varsin suoraviivaisella toteutuksella, jossa yksinkertaisesti kirjoitettiin koko tiedosto uudestaan.
Muuntyyppisillä sovelluksilla voi olla huomattavastikin monimutkaisempia vaatimuksia.
Esimerkiksi SQL-kyselykielen perustoiminnallisuuksiin kuuluvat transaktiot,
joiden avulla relaatiotietokannassa voidaan atomisesti päivittää useita, mahdollisesti eri tauluihin kuuluvia rivejä atomisesti~\cite{DatabaseFundamentals}.
Jo yksittäiset tietokannat voivat nykyään kuitenkin olla useiden teratavujen kokoisia ja käsitellä useita toisistaan riippumattomia kirjoitustransaktioita rinnakkain~\cite{DatabaseFundamentals}.
Selvästikin kelvollisen suorituskyvyn saavuttamiseksi koko tietokannan uudelleen kirjoitus joka transaktion yhteydessä ei tule kysymykseen tällaisessa käyttötapauksessa,
vaan tietokannan ohjelmoijan täytyy itse suunnitella jokin mekanismi jolla kaatumistilanteessa voidaan palauttaa tietokannan tila konsistentiksi.
Näitä sovellusten käyttämiä mekanismejä kutsutaan \emph{päivitysprotokolliksi} (\emph{update protocol})~\cite{PosixDataConsistency}.
Erinäisten sovellusten päivitysprotokollien tutkimista varten kehitetty työkalu ALICE (\emph{Application-Level Intelligent Crash Explorer}) toimii samantyyppisellä periaatteella kuin aiemmin kuvattu BOB:
testattavan sovelluksen tekemät tiedostojärjestelmäkutsut nauhoitetaan lokitiedostoon,
joista voidaan jälkikäteen simuloida mahdollisia kaatumistilanteita.
% FIXME: Continue...

\section{ext2-tiedostojärjestelmä}
Edellisissä kappaleissa nähtiin sovellusohjelmoijan näkökulmasta millaisia tiedostojärjestelmärajapintoja POSIX-spesifikaatio antaa sovellusten käytettäväksi sekä kuinka niitä täytyy käyttää oikein kaatumisturvallisuuden säilyttämiseksi.
Nyt siirrytään tarkastelemaan miten itse tiedostojärjestelmän pitää toimia jotta kaatumisturvallisuus säilyy koko kokonaisuuden kannalta.
Esimerkiksi aiemmin nähdyn tekstieditoriesimerkin toiminnan kannalta on kriittistä että \texttt{rename()}-kutsu toimii atomisesti,
joten tiedostojärjestelmän täytyy siis pystyä toteuttamaan tämä sekä joitakin muita lupauksia tiedostojärjestelmäkutsujen toiminnasta.
Tässä kappaleessa vastataan näihin kysymyksiin perehtymällä Linuxin \texttt{ext2}-tiedostojärjestelmän sisäiseen toimintaan ja sen rakenteeseen levyllä.
Tiedostojärjestelmän levyrakenne vaikuttaa olennaisesti siihen minkälaisia epäkonsistenttiuksia tiedostojärjestelmään voi syntyä virhetilanteissa,
joten vahva ymmärrys ext2:n levyformaatista on tarpeen tutkittaessa ext2:n käyttäytymistä kaatumistilanteessa luvussa~\ref{ChapExt2Crash}.
Lisäksi ext2:n levyrakenne on vahvasti BSD-käyttöjärjestelmän Berkeley Fast Filesystem-tiedostojärjestelmän inspiroima~\cite{Ext2Design},
sekä yleisestikin ottaen on varsin suoraviivainen tapa toteuttaa Unix-tyylinen tiedostojärjestelmä,
joten ext2:n ymmärrys auttaa merkittävästi muidenkin saman aikakauden Unix-tyylisten tiedostojärjestelmien ymmärtämisessä.

\subsection{Historia}

ext2 (``Second extended filesystem'') on tiedostojärjestelmä joka on luotu jo Linuxin varhaisina aikoina, vuosina 1992--1993~\cite{Ext2Design}.
Tätä ennen Linuxilla ei ollut omaa varta vasten suunniteltua tiedostojärjestelmää,
vaan se käytti MINIX-käyttöjärjestelmän tiedostojärjestelmää vain koska Linuxin alkuperäinen kehitys oli tehty MINIXillä.
MINIX-tiedostojärjestelmä kuitenkin sisälsi erinäisiä rajoitteita jotka alkoivat haittaamaan.
Esimerkiksi tiedostonimen pituus oli rajoitettu 14 merkkiin ja tiedoston koko 64 megatavuun~\cite{Ext2Design}.
\texttt{ext2} ei ainoastaan korjaa näitä puutteita,
mutta on lisäksi suunniteltu siten että tiedostojärjelmän levyformaattia voidaan laajentaa taaksepäin yhteensopivasti.
Ext2:lle onkin kehitetty seuraajat \texttt{ext3} ja \texttt{ext4} joissa olemassaoleva \texttt{ext2}- tai \texttt{ext3}-osio voidaan päivittää seuraavaan
versioon ilman tiedostojärjestelmän uudelleenformatointia~\cite{Ext4Status}.
Erityisesti mainittakoon \texttt{ext3}:n tuoma kirjaus, joka parantaa merkittävästi \texttt{ext2}:n kykyä säilyä konsistenttina kaatumistilanteessa.
Ext3:a ja kirjaavia tiedostojärjestelmiä yleisesti käsitelläänkin myöhemmin luvussa~\ref{ChapJournallingFs}.

\begin{figure}
    \label{FigExt2DiskFormat}
    \centering
    \includegraphics[width=0.7\textwidth]{gfx/ext2-structure.pdf}
    \caption{Ext2:n rakenne levyllä.}
\end{figure}

Ext2:n levyrakenne korkealla tasolla on esitetty kuvaajassa \ref{FigExt2DiskFormat}.
Korkeimmalla tasolla ext2:n rakenne on jaettu kahteen osaan: on \emph{käynnistyslohkoon} sekä useisiin \emph{lohkoryhmiin}.
Käynnistyslohkon tarkoitus on yksinkertaisesti varattua tilaa jollekin ext2:ta riippumattomalle käynnistyslataajalle,
itse tiedostojärjestelmä ei käytä tätä tilaa mitenkään.
Valtaosa ext2:n levynkäytöstä on lohkoryhmiä,
joista jokainen lohkoryhmä viimeistä lukuunottamatta vie yhtä paljon tilaa levyltä.
Jokainen ext2:n lohkoryhmä on puolestaan jaettu seuraaviin tietorakenteisiin:
\emph{superlohkoon} (superblock), 
\emph{lohkoryhmien kuvaajiin} (block group descriptors),
\emph{lohkobittikarttoihin} (block bitmap),
\emph{inodebittikarttoihin} (inode bitap),
\emph{inodetauluun} (inode table) sekä datalohkoihin.
Näistä superlohko ja lohkoryhmien kuvaajat ovat koko tiedostojärjestelmälle yhtenäistä metadataa,
joiden periaatteessa riittäisi olla levyllä vain kerran,
ja itse asiassa Linux-ajuri käyttääkin vain ensimmäisestä lohkoryhmästä löytyviä rakenteita.
Ext2:ssa on kuitenkin molemmista tietorakenteista on kopio jokaisessa lohkoryhmässä korruptoitumisen varalta.

\subsection{Superlohkon sisältö}
Superlohko sisältää muunmuassa seuraavanlaisia arvoja tiedostojärjestelmästä, enkoodattuna 32-bittisinä little-endian-kokonaislukuina:
\begin{itemize}
    \item Tiedostojärjestelmän lohkon (block) koko \texttt{s\_log\_block\_size}. Yleisesti käytettyjä lohkon kokoja on 1, 2, ja 4 kilotavua.
          Mahdollisia tiedostojärjestelmän lohkokokoja rajoittaa se, että lohkon koon täytyy olla käytettävän levyn sektorin koon moninkerta.
          Yleisimmät käytetyt sektorin koot nykypäivänä ovat 512 ja 4096 tavua.
          Myöskin Linuxin ext2-ajurilla on lisärajoituksena että lohkon koko ei saa ylittää prosessoriarkkitehtuurin sivun kokoa,
          mikä yleisemmin (muun muassa Intelin x86-arkkitehtuurissa) on 4096 tavua.
    \item Ominaisuusbitit \texttt{s\_feature\_compat}, \texttt{s\_feature\_incompat} ja \texttt{s\_feature\_ro\_compat} jotka kertovat mitä laajennoksia tiedostojärjestelmässä on käytössä.
          Nämä ovat jaettu kolmeen eri luokkaan mikä mahdollistaa sekä taaksepäin- että eteenpäinyhteensopivuuden tietyissä rajoissa.
    \item Lohkoryhmien koot, erikseen datalohkoille ja inodeille.
          \texttt{s\_blocks\_per\_group} kertoo datalohkojen määrän yhdessä lohkoryhmässä ja \texttt{s\_inodes\_per\_group} inodejen lukumäärän yhdessä lohkoryhmässä.
    \item Vapaiden datalohkojen määrä \texttt{s\_free\_blocks\_count} ja datalohkojen kokonaismäärä \texttt{s\_blocks\_count}.
    \item Niinikään samat laskurit inodeille: \texttt{s\_free\_inodes\_count} kertoo vapaiden inodejen määrän ja \texttt{s\_inodes\_count} inodejen kokonaismäärän tiedostojärjestelmässä.
\end{itemize}

Ext2:ssa inodeille on varattu tila joka on erillinen datalohkoista.
Tiedostojärjestelmää luodessa valitut \texttt{s\_blocks\_per\_group}- ja \texttt{s\_inodes\_per\_group}-parametrit määräävät inodejen ja datalohkojen suhteellisen osuuden koko levytilasta.
Ext2:aa käyttäessä voikin joutua tilanteeseen, jossa käyttäjän näkökulmasta levytilaa (eli datalohkoja) on runsaasti vapaana, mutta kaikki inodet ovat käytössä, tai päinvastoin.

\subsection{Lohkoryhmäkuvaajien sisältö}
Kuten superlohkon kohdalla, lohkoryhmäkuvaajista säilytetään kopioita useassa kohtaa levyä.
Lohkoryhmäkuvaajat on yksinkertaisesti taulukko seuraavista tietorakenteesta:
\begin{itemize}
    \item \texttt{bg\_block\_bitmap} kertoo lohkon josta kyseisen lohkoryhmän lohkobittikartta alkaa.
          Bittikartan bitit kertovat mitkä lohkoryhmän datalohkoista ovat käytössä.
          Ykkösbitti tarkoittaa käytössä olevaa lohkoa ja nollabitti vapaata lohkoa.
    \item \texttt{bg\_inode\_bitmap} kertoo lohkon josta kyseisen lohkoryhmän inodebittikartta sijaitsee.
          Inodebittikartta kertoo mitkä kyseisen lohkoryhmän inodeista on käytössä.
          Samaan tapaan kuin lohkobittikartan kanssa, 1 tarkoittaa käytössä olevaa inodea ja 0 vapaata inodea.
    \item \texttt{bg\_free\_blocks\_count} ja \texttt{bg\_free\_inodes\_count} kertovat vapaiden lohkojen ja inodejen lukumäärän kyseisessä lohkoryhmässä.
          % Koska nämä kentät ovat vain 16-bittisiä, yhden lohkoryhmän 
    \item \texttt{bg\_inode\_table} kertoo mistä lohkosta kyseisen lohkoryhmän inodetaulu alkaa. Lohkoryhmän datalohkot sijaitsevat heti lohkoryhmän inodetaulun jälkeen.
\end{itemize}

\subsection{Inoden rakenne}

Ext2:ssa tietyn inoden paikannus inodenumeron perusteella on yksinkertaista.
Kuten edellä nähtiin, jokaisessa lohkoryhmässä on sama määrä inodeja ja lohkoryhmän sisällä inodet sijaitsevat yksinkertaisesti taulukossa.
Inodeiden numerointi alkaa ykkösestä, joten inoden numerosta voidaan laskea lohkoryhmän numero kaavalla:
$$ n_\text{bg} = \frac{n_\text{ino} - 1}{\texttt{s\_inodes\_per\_group}} $$

Kenttä \texttt{i\_blocks} viittaa lohkoihin jossa inoden data sijaitsee.
Kentän formaatti on 15-alkioinen taulukko 32-bittisiä kokonaislukuja jonka sisältö tulkitaan seuraavasti:
\begin{itemize}
    \item Taulukon ensimmäiset 12 alkiota sisältävät lohkonumerot tiedoston ensimmäiselle 12 lohkolle (lohkot 0--11).
          Nämä ovat \emph{suoria lohkoja} (direct blocks).
    \item Taulukon seuraava (13.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{epäsuoraan lohkoon} (indirect block).
          Itse epäsuora lohko taas sisältää taulukon lohkonumeroita, jotka kertovat inoden seuraavat datalohkojen numerot.
          Esimerkiksi jos tiedostojärjestelmän lohkokoko on 4096, sisältää epäsuora lohko 1024 lohkonumeroa,
          jolloin lohkot 12 -- 1035 löytyvät ensimmäisen epäsuoran lohkon kautta.
    \item Taulukon seuraava (14.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{toisen tason epäsuoraan lohkoon} (doubly indirect block).

    \item Taulukon seuraava (15.) alkio kertoo lohkonumeron, joka viittaa ensimmäiseen \emph{kolmannen tason epäsuoraan lohkoon} (triply indirect block).
\end{itemize}

\begin{figure}
    \label{FigExt2BlockMap}
    \centering
    \includegraphics[width=1.1\textwidth]{gfx/ext2-blocks.pdf}
    \caption{Ext2:n lohkopuu.}
\end{figure}

\subsection{Hakemiston rakenne}
Ext2:n hakemisto koostuu \emph{hakemistoalkioista} (directory entry) jotka sijaitsevat inoden datalohkoissa.
Hakemistoalkion koko on vaihtelevanmittainen riippuen hakemistoalkion sisältämän tiedostonimen pituudesta.
Hakemistoalkio sijaitsee aina kokonaan yhden datalohkon sisällä.
Hakemistoalkio koostuu vakiokokoisesta otsakkeesta jota välittömästi seuraa tiedostonimi.
Otsakkeen rakenne on seuraavanlainen:

\begin{verbatim}
	uint32_t inode;
	uint16_t rec_len;
	uint8_t name_len;
	uint8_t file_type;
\end{verbatim}

Kenttä \texttt{inode} sisältää hakemistoalkion viittavan inoden numeron.
Mikäli inoden numero on nolla, on kyseinen hakemisto
Otsakkeen kenttä \texttt{name\_len} kertoo tiedostonimen pituuden.
Koska kentän koko on 8 bittiä, rajoittuu tiedostonimen maksimipituudeksi 255.
Kenttä \texttt{rec\_len} kertoo koko hakemistoalkion koon,
jonka perusteella voidaan paikantaa hakemiston seuraava hakemistoalkio.
joka voi olla suurempi kuin otsakkeen koko ja tiedostonimen pituus.

ext2:ssa siis hakemistoalkion paikantaminen tiedostonimen perusteella on aikavaativuudeltaan $O(n)$,
mikä tarkoittaa heikkoa suorituskykyä hakemiston koon kasvaessa.
Yksi ext2:n välittömän seuraajan, ext3:n tuomista uudistuksista on hajautukseen pohjautuva hakemistorakenne.

\subsection{Esimerkki hakemistosta}
Tarkastellaan hakemiston rakennetta luotaessa 1024 tavun lohkokokoa käyttävän tiedostojärjestelmän juureen alihakemisto \texttt{dir} ja sinne tyhjät tiedostot \texttt{abc}, \texttt{defghijklmn} ja \texttt{opqrstuvwxyz}.
Linux-ajurin luoma rakenne on seuraavanlainen:

\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    12 & 12  & 1  & "."            sekä 3 0-tavua. \\
    2  & 12  & 2  & ".."           sekä 2 0-tavua. \\
    13 & 12  & 3  & "abc"          sekä 1 0-tavu. \\
    14 & 20  & 11 & "defghijklmn"  sekä 1 0-tavu. \\
    15 & 968 & 12 & "opqrstuvwxyz" sekä loput lohkosta ovat 0-tavuja. \\
\end{tabular}

Nyt poistettaessa tiedosto \texttt{defghijklmn} muuttuu kolmannen hakemistoalkion (nimen \texttt{abc}) sisällöksi:
\begin{tabular}{llll}
    \texttt{inode} & \texttt{rec\_len} & \texttt{name\_len} & tiedostonimi \\ \hline
    13 & 20  & 3  & "abc"\\
\end{tabular}

Siis poistettavaa hakemistoalkiota edeltävän hakemistoalkion \texttt{rec\_len}-kenttää kasvatetään ``hyppäämään'' poistetun alkion yli.

\section{ext2 kaatumistilanteissa}
\label{ChapExt2Crash}

Edellisessä luvussa käytiin lävitse ext2:n tärkeimpiä levyllä sijaitsevia tietorakenteita.
Tarkastellaan nyt minkälaisia levykirjoituksia Linuxin ext2-tiedostojärjestelmäajuri käytännössä tekee kun suoritetaan joitakin POSIX-tiedostojärjestelmäoperaatioita.
Lisäksi tutkitaan mitä epäkonsistenssiuksia tiedostojärjestelmään voi aiheutua kaatumistilanteen sattuessa ja kuinka ext2:n tarkastusohjelma \texttt{e2fsck} suhtautuu niihin.

\subsection{Tiedoston luominen}
% Tarkastellaan Linuxin ext2-ajurin tekemiä levykirjoituksia luotaessa tyhjän ext2-tiedostojärjestelmän juurihakemistoon uusi tyhjä tiedosto komennolla \texttt{touch new}.
% Havaittiin seuraavat operaatiot:
%
% \begin{enumerate}
%     \item{Juurihakemistoon luodaan uusi hakemistoalkio nimelle \texttt{new} osoittamaan inodeen 13.}
%     \item{Inode 13 merkitään varatuksi inodebittikarttaan.}
%     \item{Juurihakemiston inoden aikaleimaa (\texttt{i\_mtime}) päivitetään.}
%     \item{Inoden rakenne inodetaulussa täytetään.}
%     \item{Superlohkon vapaiden inodejen määrää vähennetään yhdellä.}
%     \item{Lohkoryhmän 0 vapaiden inodejen määrää vähennetään yhdellä.}
% \end{enumerate}
%
% Yhteensä siis koko operaation suorittamiseen vaaditaan kuusi levykirjoitusta viiteen eri tietorakenteeseen levyllä.
% Nyt kaatumistilanteessa tämän operaation aikana voi olla seuraavia vaikutuksia.
% Mikäli kaatuminen tapahtuu levykirjoitusten 4--5 tai 5--6 välissä,
% ovat vain vapaiden inodejen laskurit epäkonsistentteja itse levyn kanssa.
% Tällä ei sinänsä pitäisi olla muuta merkitystä tiedostojärjestelmälle kuin että käyttäjä näkee vapaiden inodejen määrän (komennolla \texttt{df -i}) väärin.
% Sen sijaan kaatuminen kirjoitusten 1--2, 2--3 tai 3--4 välillä johtaa hakemistoalkioon mikä osoittaa alustamattomaan inodeen.
% Lisäksi kaatuminen kirjoitusten 1--2 välissä johtaa edellisten ongelmien lisäksi uuteen ongelmatilanteeseen jossa hakemistoalkio viittaa inodeen jota ei ole varattu inodebittikartassa.

\subsection{Tiedostojärjestelmän tarkistusohjelma \emph{fsck}}
(TODO: pitäisi siirtää johonkin toiseen kohtaan)

Tiedostojärjestelmän mukana jaellaan tyypillisesti \emph{fsck (file system check)}-niminen tarkastusohjelma joka pyrkii tarkistamaan tiedostojärjestelmän metadatan oikeellisuuden ja tarvittaessa korjaamaan kohdattuja ongelmia.
Ext2:n mukana tuleekin \texttt{e2fsck}-niminen tarkistustyökalu jonka toimintaa kuvaillaan tässä luvussa.

\subsubsection{Toiminta}

Tyypillinen vaatimus tiedostojärjestelmän tarkistusohjelmilta on että niiden kuuluu toimia monentyyppisten korruptioiden kanssa.
Kaatumistilanteiden lisäksi korruptioita voi aiheutua tiedostojärjestelmäajurin ohjelmointivirheistä tai laitteiston aiheuttamista ongelmista.
Koska \texttt{e2fsck}:n täytyy käydä koko tiedostojärjestelmän metadata läpi,
pitää jo koko metadatan paikantamisessa olla varovainen,
koska johonkin muuhun metadataan viittaava kenttä itsessään voi olla korruptoitunut.
Myöskin metadataan tehtävät korjaukset on tärkeä tehdä tietyssä järjestyksessä.

\texttt{e2fsck} käy tiedostojärjestelmän läpi kuudessa vaiheessa:
\begin{enumerate}
    \item{Superlohko}
\end{enumerate}

\section{Kirjaavat tiedostojärjestelmät}
\label{ChapJournallingFs}
Edellisissä kappaleissa kuvailtiin ext2-tiedostojärjestelmä ja sen käyttäytyminen kaatumistilanteissa.
Koska kaatumistilanteen aiheuttamien seuraamuksien todettiin olevan varsin ikäviä,
ovat monet ext2:ta edistyneemmät tiedostojärjestelmät kehittäneet menetelmiä kaatumistilanteita varten.
Eräs varsin laajasti käytetty tekniikka on \emph{kirjaavat tiedostojärjestelmät} (\emph{journalling file systems}).
Tätä tekniikkaa käyttääkin ext2:n seuraaja ext3, sekä sen lisäksi
muun muassa IBM:n JFS sekä Microsoftin NTFS~\cite{JournalingAnalysis}.
Kirjauksen toteuttaminen tiedostojärjestelmään voidaan tehdä muutamalla eri lähestymistavalla.
Tässä kappaleessa kuitenkin tarkastellaan pääosin ext3:n toteutusta kirjauksesta.

\subsection{Motivaatio}

Tarve ext2:n jatkokehitykselle syntyi pääosin kaatumistilanteista selviämiseen,
sillä kiintolevyjen koon kasvaessa kasvoi myös \texttt{fsck}-ohjelman viemä aika samaa tahtia~\cite{Ext2Journal}.
Tavoitteeksi asetettiin luoda menetelmä kaatumistilanteista selviämiseen joka ei vaadi pitkää palautumisaikaa jolloin tiedostojärjestelmä ei ole käytettävissä.
Nopeuden lisäksi samalla tavoiteltiin parannuksia tiedostojärjestelmän kaatumisesta palautumiseen seuraavilla kriteereillä: säilyvyys, ennakoitavuus, ja atomisuus~\cite{Ext2Journal}.
Säilyvyydellä tarkoitetaan että aikaisemmin onnistuneesti turvallisesti levylle kirjoitettujen tiedostojen sisällöt pysyvät sellaisenaan.
Ext2-tiedostojärjestelmän \emph{fsck}-pohjainen palautumismekanismi täyttää tämän kriteerin jo valmiiksi,
joten sen seuraajankin kuuluu täyttää tämä kriteeri.
Atomisuuskriteeri vaatii että tietyt loogisesti yksittäiset tiedostojärjestelmäoperaatiot tapahtuvat
joko kokonaan loppuun asti tai eivät ollenkaan.
Kuten aiemmin nähtiin, tämä kriteeri ei täyty ext2:n kohdalla uudelleennimettäessä tiedostoa hakemistosta toiseen,
vaan fsck-ohjelman ajamisesta huolimatta voidaan päätyä joko tiedoston katoamiseen tai tilanteeseen jossa sekä uusi että tiedostonimi ovat olemassa.
Ennakoitavuus tarkoittaa että kaikkien tilanteiden josta tiedostojärjestelmä joutuu palautumaan kaatumistilanteessa ovat ennakoitavissa.
Nykyisen ext2:n kohdalla näin ei ole, sillä levyvälimuistien takia kaatumistilanteen aikana voi olla useita ...

Yksi tapa kaikkien näiden kriteereiden täyttämiseksi on suunnitella menetelmä jolla koko tiedostojärjestelmän metadatan voidaan tehdä päivityksiä atomisesti.
Tähän on useita mahdollisia tapoja, mutta ext2:n kehittäjät valitsivat kirjauksen.

\subsection{Kirjauksen toimintaperiaate}

Kirjauksen perusperiaate pohjautuu pääpiirteissään tietokantajärjestelmissä käytettyyn Write-Ahead Logging-menetelmään~\cite{AriesWal}.
Ennen metadatalohkojen kirjoitusta niiden varsinaisille paikalleen levyllä, kopio niistä kirjataan lokiin.
Kirjauksen vaatima loki on kiinteän pituinen ja tila sille on varattu piilotetun, tiedostojärjestelmän käyttäjällä näkymättömän inoden avulla.

\section{Kirjoitusjärjestyksen hallintaan perustuvat tiedostojärjestelmät (``soft updates'')}
\label{ChapSoftUpdates}
Tässä kappaleessa tarkastellaan Berkeley Fast Filesystem (FFS)-tiedostojärjestelmään toteutettua soft updates-mekanismiä~\cite{SoftUpdatesFfs}.
Ext2:sta poiketen FFS-tiedostojärjestelmälle ei löydy tukea Linuxista,
vaan tarkasteltavana on toteutus 90-luvun BSD 4.4-käyttöjärjestelmästä.

\section{Lokipohjaiset (``log-structured'') tiedostojärjestelmät}
\label{ChapLogStructured}
Aiemmissa kappaleissa käsitellyt ext2/ext3 ja Berkeley FFS ovat niin sanottuja päälle kirjoittavia tiedostojärjestelmiä (\emph{overwrite-based filesystem}~\cite{Btrfs}).
Esimerkiksi aiemmin ext3:n yhteydessä nähtiin kuinka olemassaolevaa tiedostoa uudelleennimettäessä
alkuperäisen tiedostonimen hakemistoalkion sisältävä sektorilta poistetaan vanha hakemistoalkio
ja vastaavasti kohdehakemistossa lisätätään uusi hakemistoalkio.
Mutta koska kahden eri levylohkon päivitys atomisesti ei ole mahdollista,
kirjoittaa ext3 myös kopiot lohkoista journaliin josta molemmat varsinaiset hakemistolohkot voidaan tarvittaessa palauttaa kaatumistilanteen sattuessa.
Siis yleisesti ottaen ext3 kirjoittaa kaiken metadatan kahdesti.

\section{Kirjoittaessa kopioivat tiedostojärjestelmät}
\label{ChapCopyOnWrite}
Kolmas yleinen tiedostojärjestelmien variaatio päälle kirjottavien ja lokipohjaisten tiedostojärjestelmien lisäksi on kirjoittaessa kopioivat (``CoW, Copy-on-Write'') tiedostojärjestelmät.
Tässä kappaleessa tarkastellaan tähän tekniikkaan perustuvaa Linuxin \texttt{btrfs}-tiedostojärjestelmää~\cite{Btrfs}.

\section{Tiedostojärjestelmätoteutusten luotettavuuden testaus}

Edellisissä luvuissa käsiteltiin joukko mekanismejä joiden avulla tiedostojärjestelmät voivat varmistaa omien sisäisten tietorakenteidensa konsistenssin säilymisen kaatumistilanteessa.
Lienee kuitenkin selkeää että nämä tekniikat pelkästään paperilla eivät vielä takaa itse toteutuksen toimivuutta,
vaan itse toteutuksen oikeellisuus pitää erikseen todeta esimerkiksi mahdollisten ohjelmointivirheiden varalta.
Linuxin tiedostojärjestelmätoteutuksien oikeellisuutta onkin tutkittu muun muassa mallintarkistamisen avulla teoksessa ``Using Model Checking to Find Serious File System Errors''~\cite{ModelChecking}.

\section{Yhteenveto}

...
